{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/* eslint no-constant-condition:0 */\nvar functions = require(\"./functions\");\nvar environments = require(\"./environments\");\nvar Lexer = require(\"./Lexer\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The earlier functions return ParseNodes.\n * The later functions (which are called deeper in the parse) sometimes return\n * ParseFuncOrArgument, which contain a ParseNode as well as some data about\n * whether the parsed object is a function which is missing some arguments, or a\n * standalone object which can be used as an argument to another function.\n */\n\n/**\n * Main Parser class\n */\nfunction Parser(input, settings) {\n  // Make a new lexer\n  this.lexer = new Lexer(input);\n  // Store the settings for use in parsing\n  this.settings = settings;\n}\nvar ParseNode = parseData.ParseNode;\n\n/**\n * An initial function (without its arguments), or an argument to a function.\n * The `result` argument should be a ParseNode.\n */\nfunction ParseFuncOrArgument(result, isFunction) {\n  this.result = result;\n  // Is this a function (i.e. is it something defined in functions.js)?\n  this.isFunction = isFunction;\n}\n\n/**\n * Checks a result to make sure it has the right type, and throws an\n * appropriate error otherwise.\n *\n * @param {boolean=} consume whether to consume the expected token,\n *                           defaults to true\n */\nParser.prototype.expect = function (text, consume) {\n  if (this.nextToken.text !== text) {\n    throw new ParseError(\"Expected '\" + text + \"', got '\" + this.nextToken.text + \"'\", this.lexer, this.nextToken.position);\n  }\n  if (consume !== false) {\n    this.consume();\n  }\n};\n\n/**\n * Considers the current look ahead token as consumed,\n * and fetches the one after that as the new look ahead.\n */\nParser.prototype.consume = function () {\n  this.pos = this.nextToken.position;\n  this.nextToken = this.lexer.lex(this.pos, this.mode);\n};\n\n/**\n * Main parsing function, which parses an entire input.\n *\n * @return {?Array.<ParseNode>}\n */\nParser.prototype.parse = function () {\n  // Try to parse the input\n  this.mode = \"math\";\n  this.pos = 0;\n  this.nextToken = this.lexer.lex(this.pos, this.mode);\n  var parse = this.parseInput();\n  return parse;\n};\n\n/**\n * Parses an entire input tree.\n */\nParser.prototype.parseInput = function () {\n  // Parse an expression\n  var expression = this.parseExpression(false);\n  // If we succeeded, make sure there's an EOF at the end\n  this.expect(\"EOF\", false);\n  return expression;\n};\nvar endOfExpression = [\"}\", \"\\\\end\", \"\\\\right\", \"&\", \"\\\\\\\\\", \"\\\\cr\"];\n\n/**\n * Parses an \"expression\", which is a list of atoms.\n *\n * @param {boolean} breakOnInfix Should the parsing stop when we hit infix\n *                  nodes? This happens when functions have higher precendence\n *                  than infix nodes in implicit parses.\n *\n * @param {?string} breakOnToken The token that the expression should end with,\n *                  or `null` if something else should end the expression.\n *\n * @return {ParseNode}\n */\nParser.prototype.parseExpression = function (breakOnInfix, breakOnToken) {\n  var body = [];\n  // Keep adding atoms to the body until we can't parse any more atoms (either\n  // we reached the end, a }, or a \\right)\n  while (true) {\n    var lex = this.nextToken;\n    var pos = this.pos;\n    if (endOfExpression.indexOf(lex.text) !== -1) {\n      break;\n    }\n    if (breakOnToken && lex.text === breakOnToken) {\n      break;\n    }\n    var atom = this.parseAtom();\n    if (!atom) {\n      if (!this.settings.throwOnError && lex.text[0] === \"\\\\\") {\n        var errorNode = this.handleUnsupportedCmd();\n        body.push(errorNode);\n        pos = lex.position;\n        continue;\n      }\n      break;\n    }\n    if (breakOnInfix && atom.type === \"infix\") {\n      // rewind so we can parse the infix atom again\n      this.pos = pos;\n      this.nextToken = lex;\n      break;\n    }\n    body.push(atom);\n  }\n  return this.handleInfixNodes(body);\n};\n\n/**\n * Rewrites infix operators such as \\over with corresponding commands such\n * as \\frac.\n *\n * There can only be one infix operator per group.  If there's more than one\n * then the expression is ambiguous.  This can be resolved by adding {}.\n *\n * @returns {Array}\n */\nParser.prototype.handleInfixNodes = function (body) {\n  var overIndex = -1;\n  var funcName;\n  for (var i = 0; i < body.length; i++) {\n    var node = body[i];\n    if (node.type === \"infix\") {\n      if (overIndex !== -1) {\n        throw new ParseError(\"only one infix operator per group\", this.lexer, -1);\n      }\n      overIndex = i;\n      funcName = node.value.replaceWith;\n    }\n  }\n  if (overIndex !== -1) {\n    var numerNode;\n    var denomNode;\n    var numerBody = body.slice(0, overIndex);\n    var denomBody = body.slice(overIndex + 1);\n    if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n      numerNode = numerBody[0];\n    } else {\n      numerNode = new ParseNode(\"ordgroup\", numerBody, this.mode);\n    }\n    if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n      denomNode = denomBody[0];\n    } else {\n      denomNode = new ParseNode(\"ordgroup\", denomBody, this.mode);\n    }\n    var value = this.callFunction(funcName, [numerNode, denomNode], null);\n    return [new ParseNode(value.type, value, this.mode)];\n  } else {\n    return body;\n  }\n};\n\n// The greediness of a superscript or subscript\nvar SUPSUB_GREEDINESS = 1;\n\n/**\n * Handle a subscript or superscript with nice errors.\n */\nParser.prototype.handleSupSubscript = function (name) {\n  var symbol = this.nextToken.text;\n  var symPos = this.pos;\n  this.consume();\n  var group = this.parseGroup();\n  if (!group) {\n    if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n      return this.handleUnsupportedCmd();\n    } else {\n      throw new ParseError(\"Expected group after '\" + symbol + \"'\", this.lexer, symPos + 1);\n    }\n  } else if (group.isFunction) {\n    // ^ and _ have a greediness, so handle interactions with functions'\n    // greediness\n    var funcGreediness = functions[group.result].greediness;\n    if (funcGreediness > SUPSUB_GREEDINESS) {\n      return this.parseFunction(group);\n    } else {\n      throw new ParseError(\"Got function '\" + group.result + \"' with no arguments \" + \"as \" + name, this.lexer, symPos + 1);\n    }\n  } else {\n    return group.result;\n  }\n};\n\n/**\n * Converts the textual input of an unsupported command into a text node\n * contained within a color node whose color is determined by errorColor\n */\nParser.prototype.handleUnsupportedCmd = function () {\n  var text = this.nextToken.text;\n  var textordArray = [];\n  for (var i = 0; i < text.length; i++) {\n    textordArray.push(new ParseNode(\"textord\", text[i], \"text\"));\n  }\n  var textNode = new ParseNode(\"text\", {\n    body: textordArray,\n    type: \"text\"\n  }, this.mode);\n  var colorNode = new ParseNode(\"color\", {\n    color: this.settings.errorColor,\n    value: [textNode],\n    type: \"color\"\n  }, this.mode);\n  this.consume();\n  return colorNode;\n};\n\n/**\n * Parses a group with optional super/subscripts.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseAtom = function () {\n  // The body of an atom is an implicit group, so that things like\n  // \\left(x\\right)^2 work correctly.\n  var base = this.parseImplicitGroup();\n\n  // In text mode, we don't have superscripts or subscripts\n  if (this.mode === \"text\") {\n    return base;\n  }\n\n  // Note that base may be empty (i.e. null) at this point.\n\n  var superscript;\n  var subscript;\n  while (true) {\n    // Lex the first token\n    var lex = this.nextToken;\n    if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n      // We got a limit control\n      if (!base || base.type !== \"op\") {\n        throw new ParseError(\"Limit controls must follow a math operator\", this.lexer, this.pos);\n      } else {\n        var limits = lex.text === \"\\\\limits\";\n        base.value.limits = limits;\n        base.value.alwaysHandleSupSub = true;\n      }\n      this.consume();\n    } else if (lex.text === \"^\") {\n      // We got a superscript start\n      if (superscript) {\n        throw new ParseError(\"Double superscript\", this.lexer, this.pos);\n      }\n      superscript = this.handleSupSubscript(\"superscript\");\n    } else if (lex.text === \"_\") {\n      // We got a subscript start\n      if (subscript) {\n        throw new ParseError(\"Double subscript\", this.lexer, this.pos);\n      }\n      subscript = this.handleSupSubscript(\"subscript\");\n    } else if (lex.text === \"'\") {\n      // We got a prime\n      var prime = new ParseNode(\"textord\", \"\\\\prime\", this.mode);\n\n      // Many primes can be grouped together, so we handle this here\n      var primes = [prime];\n      this.consume();\n      // Keep lexing tokens until we get something that's not a prime\n      while (this.nextToken.text === \"'\") {\n        // For each one, add another prime to the list\n        primes.push(prime);\n        this.consume();\n      }\n      // Put them into an ordgroup as the superscript\n      superscript = new ParseNode(\"ordgroup\", primes, this.mode);\n    } else {\n      // If it wasn't ^, _, or ', stop parsing super/subscripts\n      break;\n    }\n  }\n  if (superscript || subscript) {\n    // If we got either a superscript or subscript, create a supsub\n    return new ParseNode(\"supsub\", {\n      base: base,\n      sup: superscript,\n      sub: subscript\n    }, this.mode);\n  } else {\n    // Otherwise return the original body\n    return base;\n  }\n};\n\n// A list of the size-changing functions, for use in parseImplicitGroup\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\n\n// A list of the style-changing functions, for use in parseImplicitGroup\nvar styleFuncs = [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"];\n\n/**\n * Parses an implicit group, which is a group that starts at the end of a\n * specified, and ends right before a higher explicit group ends, or at EOL. It\n * is used for functions that appear to affect the current style, like \\Large or\n * \\textrm, where instead of keeping a style we just pretend that there is an\n * implicit grouping after it until the end of the group. E.g.\n *   small text {\\Large large text} small text again\n * It is also used for \\left and \\right to get the correct grouping.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseImplicitGroup = function () {\n  var start = this.parseSymbol();\n  if (start == null) {\n    // If we didn't get anything we handle, fall back to parseFunction\n    return this.parseFunction();\n  }\n  var func = start.result;\n  var body;\n  if (func === \"\\\\left\") {\n    // If we see a left:\n    // Parse the entire left function (including the delimiter)\n    var left = this.parseFunction(start);\n    // Parse out the implicit body\n    body = this.parseExpression(false);\n    // Check the next token\n    this.expect(\"\\\\right\", false);\n    var right = this.parseFunction();\n    return new ParseNode(\"leftright\", {\n      body: body,\n      left: left.value.value,\n      right: right.value.value\n    }, this.mode);\n  } else if (func === \"\\\\begin\") {\n    // begin...end is similar to left...right\n    var begin = this.parseFunction(start);\n    var envName = begin.value.name;\n    if (!environments.hasOwnProperty(envName)) {\n      throw new ParseError(\"No such environment: \" + envName, this.lexer, begin.value.namepos);\n    }\n    // Build the environment object. Arguments and other information will\n    // be made available to the begin and end methods using properties.\n    var env = environments[envName];\n    var args = this.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n    var context = {\n      mode: this.mode,\n      envName: envName,\n      parser: this,\n      lexer: this.lexer,\n      positions: args.pop()\n    };\n    var result = env.handler(context, args);\n    this.expect(\"\\\\end\", false);\n    var end = this.parseFunction();\n    if (end.value.name !== envName) {\n      throw new ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched \" + \"by \\\\end{\" + end.value.name + \"}\", this.lexer /* , end.value.namepos */);\n      // TODO: Add position to the above line and adjust test case,\n      // requires #385 to get merged first\n    }\n\n    result.position = end.position;\n    return result;\n  } else if (utils.contains(sizeFuncs, func)) {\n    // If we see a sizing function, parse out the implict body\n    body = this.parseExpression(false);\n    return new ParseNode(\"sizing\", {\n      // Figure out what size to use based on the list of functions above\n      size: \"size\" + (utils.indexOf(sizeFuncs, func) + 1),\n      value: body\n    }, this.mode);\n  } else if (utils.contains(styleFuncs, func)) {\n    // If we see a styling function, parse out the implict body\n    body = this.parseExpression(true);\n    return new ParseNode(\"styling\", {\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style: func.slice(1, func.length - 5),\n      value: body\n    }, this.mode);\n  } else {\n    // Defer to parseFunction if it's not a function we handle\n    return this.parseFunction(start);\n  }\n};\n\n/**\n * Parses an entire function, including its base and all of its arguments.\n * The base might either have been parsed already, in which case\n * it is provided as an argument, or it's the next group in the input.\n *\n * @param {ParseFuncOrArgument=} baseGroup optional as described above\n * @return {?ParseNode}\n */\nParser.prototype.parseFunction = function (baseGroup) {\n  if (!baseGroup) {\n    baseGroup = this.parseGroup();\n  }\n  if (baseGroup) {\n    if (baseGroup.isFunction) {\n      var func = baseGroup.result;\n      var funcData = functions[func];\n      if (this.mode === \"text\" && !funcData.allowedInText) {\n        throw new ParseError(\"Can't use function '\" + func + \"' in text mode\", this.lexer, baseGroup.position);\n      }\n      var args = this.parseArguments(func, funcData);\n      var result = this.callFunction(func, args, args.pop());\n      return new ParseNode(result.type, result, this.mode);\n    } else {\n      return baseGroup.result;\n    }\n  } else {\n    return null;\n  }\n};\n\n/**\n * Call a function handler with a suitable context and arguments.\n */\nParser.prototype.callFunction = function (name, args, positions) {\n  var context = {\n    funcName: name,\n    parser: this,\n    lexer: this.lexer,\n    positions: positions\n  };\n  return functions[name].handler(context, args);\n};\n\n/**\n * Parses the arguments of a function or environment\n *\n * @param {string} func  \"\\name\" or \"\\begin{name}\"\n * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData\n * @return the array of arguments, with the list of positions as last element\n */\nParser.prototype.parseArguments = function (func, funcData) {\n  var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n  if (totalArgs === 0) {\n    return [[this.pos]];\n  }\n  var baseGreediness = funcData.greediness;\n  var positions = [this.pos];\n  var args = [];\n  for (var i = 0; i < totalArgs; i++) {\n    var argType = funcData.argTypes && funcData.argTypes[i];\n    var arg;\n    if (i < funcData.numOptionalArgs) {\n      if (argType) {\n        arg = this.parseSpecialGroup(argType, true);\n      } else {\n        arg = this.parseOptionalGroup();\n      }\n      if (!arg) {\n        args.push(null);\n        positions.push(this.pos);\n        continue;\n      }\n    } else {\n      if (argType) {\n        arg = this.parseSpecialGroup(argType);\n      } else {\n        arg = this.parseGroup();\n      }\n      if (!arg) {\n        if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n          arg = new ParseFuncOrArgument(this.handleUnsupportedCmd(this.nextToken.text), false);\n        } else {\n          throw new ParseError(\"Expected group after '\" + func + \"'\", this.lexer, this.pos);\n        }\n      }\n    }\n    var argNode;\n    if (arg.isFunction) {\n      var argGreediness = functions[arg.result].greediness;\n      if (argGreediness > baseGreediness) {\n        argNode = this.parseFunction(arg);\n      } else {\n        throw new ParseError(\"Got function '\" + arg.result + \"' as \" + \"argument to '\" + func + \"'\", this.lexer, this.pos - 1);\n      }\n    } else {\n      argNode = arg.result;\n    }\n    args.push(argNode);\n    positions.push(this.pos);\n  }\n  args.push(positions);\n  return args;\n};\n\n/**\n * Parses a group when the mode is changing. Takes a position, a new mode, and\n * an outer mode that is used to parse the outside.\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSpecialGroup = function (innerMode, optional) {\n  var outerMode = this.mode;\n  // Handle `original` argTypes\n  if (innerMode === \"original\") {\n    innerMode = outerMode;\n  }\n  if (innerMode === \"color\" || innerMode === \"size\") {\n    // color and size modes are special because they should have braces and\n    // should only lex a single symbol inside\n    var openBrace = this.nextToken;\n    if (optional && openBrace.text !== \"[\") {\n      // optional arguments should return null if they don't exist\n      return null;\n    }\n    // The call to expect will lex the token after the '{' in inner mode\n    this.mode = innerMode;\n    this.expect(optional ? \"[\" : \"{\");\n    var inner = this.nextToken;\n    this.mode = outerMode;\n    var data;\n    if (innerMode === \"color\") {\n      data = inner.text;\n    } else {\n      data = inner.data;\n    }\n    this.consume(); // consume the token stored in inner\n    this.expect(optional ? \"]\" : \"}\");\n    return new ParseFuncOrArgument(new ParseNode(innerMode, data, outerMode), false);\n  } else if (innerMode === \"text\") {\n    // text mode is special because it should ignore the whitespace before\n    // it\n    var whitespace = this.lexer.lex(this.pos, \"whitespace\");\n    this.pos = whitespace.position;\n  }\n\n  // By the time we get here, innerMode is one of \"text\" or \"math\".\n  // We switch the mode of the parser, recurse, then restore the old mode.\n  this.mode = innerMode;\n  this.nextToken = this.lexer.lex(this.pos, innerMode);\n  var res;\n  if (optional) {\n    res = this.parseOptionalGroup();\n  } else {\n    res = this.parseGroup();\n  }\n  this.mode = outerMode;\n  this.nextToken = this.lexer.lex(this.pos, outerMode);\n  return res;\n};\n\n/**\n * Parses a group, which is either a single nucleus (like \"x\") or an expression\n * in braces (like \"{x+y}\")\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseGroup = function () {\n  // Try to parse an open brace\n  if (this.nextToken.text === \"{\") {\n    // If we get a brace, parse an expression\n    this.consume();\n    var expression = this.parseExpression(false);\n    // Make sure we get a close brace\n    this.expect(\"}\");\n    return new ParseFuncOrArgument(new ParseNode(\"ordgroup\", expression, this.mode), false);\n  } else {\n    // Otherwise, just return a nucleus\n    return this.parseSymbol();\n  }\n};\n\n/**\n * Parses a group, which is an expression in brackets (like \"[x+y]\")\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseOptionalGroup = function () {\n  // Try to parse an open bracket\n  if (this.nextToken.text === \"[\") {\n    // If we get a brace, parse an expression\n    this.consume();\n    var expression = this.parseExpression(false, \"]\");\n    // Make sure we get a close bracket\n    this.expect(\"]\");\n    return new ParseFuncOrArgument(new ParseNode(\"ordgroup\", expression, this.mode), false);\n  } else {\n    // Otherwise, return null,\n    return null;\n  }\n};\n\n/**\n * Parse a single symbol out of the string. Here, we handle both the functions\n * we have defined, as well as the single character symbols\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSymbol = function () {\n  var nucleus = this.nextToken;\n  if (functions[nucleus.text]) {\n    this.consume();\n    // If there exists a function with this name, we return the function and\n    // say that it is a function.\n    return new ParseFuncOrArgument(nucleus.text, true);\n  } else if (symbols[this.mode][nucleus.text]) {\n    this.consume();\n    // Otherwise if this is a no-argument function, find the type it\n    // corresponds to in the symbols map\n    return new ParseFuncOrArgument(new ParseNode(symbols[this.mode][nucleus.text].group, nucleus.text, this.mode), false);\n  } else {\n    return null;\n  }\n};\nParser.prototype.ParseNode = ParseNode;\nmodule.exports = Parser;","map":{"version":3,"names":["functions","require","environments","Lexer","symbols","utils","parseData","ParseError","Parser","input","settings","lexer","ParseNode","ParseFuncOrArgument","result","isFunction","prototype","expect","text","consume","nextToken","position","pos","lex","mode","parse","parseInput","expression","parseExpression","endOfExpression","breakOnInfix","breakOnToken","body","indexOf","atom","parseAtom","throwOnError","errorNode","handleUnsupportedCmd","push","type","handleInfixNodes","overIndex","funcName","i","length","node","value","replaceWith","numerNode","denomNode","numerBody","slice","denomBody","callFunction","SUPSUB_GREEDINESS","handleSupSubscript","name","symbol","symPos","group","parseGroup","funcGreediness","greediness","parseFunction","textordArray","textNode","colorNode","color","errorColor","base","parseImplicitGroup","superscript","subscript","limits","alwaysHandleSupSub","prime","primes","sup","sub","sizeFuncs","styleFuncs","start","parseSymbol","func","left","right","begin","envName","hasOwnProperty","namepos","env","args","parseArguments","context","parser","positions","pop","handler","end","contains","size","style","baseGroup","funcData","allowedInText","totalArgs","numArgs","numOptionalArgs","baseGreediness","argType","argTypes","arg","parseSpecialGroup","parseOptionalGroup","argNode","argGreediness","innerMode","optional","outerMode","openBrace","inner","data","whitespace","res","nucleus","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/fruitshop/node_modules/katex/src/Parser.js"],"sourcesContent":["/* eslint no-constant-condition:0 */\nvar functions = require(\"./functions\");\nvar environments = require(\"./environments\");\nvar Lexer = require(\"./Lexer\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\n\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The earlier functions return ParseNodes.\n * The later functions (which are called deeper in the parse) sometimes return\n * ParseFuncOrArgument, which contain a ParseNode as well as some data about\n * whether the parsed object is a function which is missing some arguments, or a\n * standalone object which can be used as an argument to another function.\n */\n\n/**\n * Main Parser class\n */\nfunction Parser(input, settings) {\n    // Make a new lexer\n    this.lexer = new Lexer(input);\n    // Store the settings for use in parsing\n    this.settings = settings;\n}\n\nvar ParseNode = parseData.ParseNode;\n\n/**\n * An initial function (without its arguments), or an argument to a function.\n * The `result` argument should be a ParseNode.\n */\nfunction ParseFuncOrArgument(result, isFunction) {\n    this.result = result;\n    // Is this a function (i.e. is it something defined in functions.js)?\n    this.isFunction = isFunction;\n}\n\n/**\n * Checks a result to make sure it has the right type, and throws an\n * appropriate error otherwise.\n *\n * @param {boolean=} consume whether to consume the expected token,\n *                           defaults to true\n */\nParser.prototype.expect = function(text, consume) {\n    if (this.nextToken.text !== text) {\n        throw new ParseError(\n            \"Expected '\" + text + \"', got '\" + this.nextToken.text + \"'\",\n            this.lexer, this.nextToken.position\n        );\n    }\n    if (consume !== false) {\n        this.consume();\n    }\n};\n\n/**\n * Considers the current look ahead token as consumed,\n * and fetches the one after that as the new look ahead.\n */\nParser.prototype.consume = function() {\n    this.pos = this.nextToken.position;\n    this.nextToken = this.lexer.lex(this.pos, this.mode);\n};\n\n/**\n * Main parsing function, which parses an entire input.\n *\n * @return {?Array.<ParseNode>}\n */\nParser.prototype.parse = function() {\n    // Try to parse the input\n    this.mode = \"math\";\n    this.pos = 0;\n    this.nextToken = this.lexer.lex(this.pos, this.mode);\n    var parse = this.parseInput();\n    return parse;\n};\n\n/**\n * Parses an entire input tree.\n */\nParser.prototype.parseInput = function() {\n    // Parse an expression\n    var expression = this.parseExpression(false);\n    // If we succeeded, make sure there's an EOF at the end\n    this.expect(\"EOF\", false);\n    return expression;\n};\n\nvar endOfExpression = [\"}\", \"\\\\end\", \"\\\\right\", \"&\", \"\\\\\\\\\", \"\\\\cr\"];\n\n/**\n * Parses an \"expression\", which is a list of atoms.\n *\n * @param {boolean} breakOnInfix Should the parsing stop when we hit infix\n *                  nodes? This happens when functions have higher precendence\n *                  than infix nodes in implicit parses.\n *\n * @param {?string} breakOnToken The token that the expression should end with,\n *                  or `null` if something else should end the expression.\n *\n * @return {ParseNode}\n */\nParser.prototype.parseExpression = function(breakOnInfix, breakOnToken) {\n    var body = [];\n    // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n    while (true) {\n        var lex = this.nextToken;\n        var pos = this.pos;\n        if (endOfExpression.indexOf(lex.text) !== -1) {\n            break;\n        }\n        if (breakOnToken && lex.text === breakOnToken) {\n            break;\n        }\n        var atom = this.parseAtom();\n        if (!atom) {\n            if (!this.settings.throwOnError && lex.text[0] === \"\\\\\") {\n                var errorNode = this.handleUnsupportedCmd();\n                body.push(errorNode);\n\n                pos = lex.position;\n                continue;\n            }\n\n            break;\n        }\n        if (breakOnInfix && atom.type === \"infix\") {\n            // rewind so we can parse the infix atom again\n            this.pos = pos;\n            this.nextToken = lex;\n            break;\n        }\n        body.push(atom);\n    }\n    return this.handleInfixNodes(body);\n};\n\n/**\n * Rewrites infix operators such as \\over with corresponding commands such\n * as \\frac.\n *\n * There can only be one infix operator per group.  If there's more than one\n * then the expression is ambiguous.  This can be resolved by adding {}.\n *\n * @returns {Array}\n */\nParser.prototype.handleInfixNodes = function(body) {\n    var overIndex = -1;\n    var funcName;\n\n    for (var i = 0; i < body.length; i++) {\n        var node = body[i];\n        if (node.type === \"infix\") {\n            if (overIndex !== -1) {\n                throw new ParseError(\"only one infix operator per group\",\n                    this.lexer, -1);\n            }\n            overIndex = i;\n            funcName = node.value.replaceWith;\n        }\n    }\n\n    if (overIndex !== -1) {\n        var numerNode;\n        var denomNode;\n\n        var numerBody = body.slice(0, overIndex);\n        var denomBody = body.slice(overIndex + 1);\n\n        if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n            numerNode = numerBody[0];\n        } else {\n            numerNode = new ParseNode(\"ordgroup\", numerBody, this.mode);\n        }\n\n        if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n            denomNode = denomBody[0];\n        } else {\n            denomNode = new ParseNode(\"ordgroup\", denomBody, this.mode);\n        }\n\n        var value = this.callFunction(\n            funcName, [numerNode, denomNode], null);\n        return [new ParseNode(value.type, value, this.mode)];\n    } else {\n        return body;\n    }\n};\n\n// The greediness of a superscript or subscript\nvar SUPSUB_GREEDINESS = 1;\n\n/**\n * Handle a subscript or superscript with nice errors.\n */\nParser.prototype.handleSupSubscript = function(name) {\n    var symbol = this.nextToken.text;\n    var symPos = this.pos;\n    this.consume();\n    var group = this.parseGroup();\n\n    if (!group) {\n        if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n            return this.handleUnsupportedCmd();\n        } else {\n            throw new ParseError(\n                \"Expected group after '\" + symbol + \"'\",\n                this.lexer,\n                symPos + 1\n            );\n        }\n    } else if (group.isFunction) {\n        // ^ and _ have a greediness, so handle interactions with functions'\n        // greediness\n        var funcGreediness = functions[group.result].greediness;\n        if (funcGreediness > SUPSUB_GREEDINESS) {\n            return this.parseFunction(group);\n        } else {\n            throw new ParseError(\n                \"Got function '\" + group.result + \"' with no arguments \" +\n                    \"as \" + name,\n                this.lexer, symPos + 1);\n        }\n    } else {\n        return group.result;\n    }\n};\n\n/**\n * Converts the textual input of an unsupported command into a text node\n * contained within a color node whose color is determined by errorColor\n */\nParser.prototype.handleUnsupportedCmd = function() {\n    var text = this.nextToken.text;\n    var textordArray = [];\n\n    for (var i = 0; i < text.length; i++) {\n        textordArray.push(new ParseNode(\"textord\", text[i], \"text\"));\n    }\n\n    var textNode = new ParseNode(\n        \"text\",\n        {\n            body: textordArray,\n            type: \"text\",\n        },\n        this.mode);\n\n    var colorNode = new ParseNode(\n        \"color\",\n        {\n            color: this.settings.errorColor,\n            value: [textNode],\n            type: \"color\",\n        },\n        this.mode);\n\n    this.consume();\n    return colorNode;\n};\n\n/**\n * Parses a group with optional super/subscripts.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseAtom = function() {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    var base = this.parseImplicitGroup();\n\n    // In text mode, we don't have superscripts or subscripts\n    if (this.mode === \"text\") {\n        return base;\n    }\n\n    // Note that base may be empty (i.e. null) at this point.\n\n    var superscript;\n    var subscript;\n    while (true) {\n        // Lex the first token\n        var lex = this.nextToken;\n\n        if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n            // We got a limit control\n            if (!base || base.type !== \"op\") {\n                throw new ParseError(\n                    \"Limit controls must follow a math operator\",\n                    this.lexer, this.pos);\n            } else {\n                var limits = lex.text === \"\\\\limits\";\n                base.value.limits = limits;\n                base.value.alwaysHandleSupSub = true;\n            }\n            this.consume();\n        } else if (lex.text === \"^\") {\n            // We got a superscript start\n            if (superscript) {\n                throw new ParseError(\n                    \"Double superscript\", this.lexer, this.pos);\n            }\n            superscript = this.handleSupSubscript(\"superscript\");\n        } else if (lex.text === \"_\") {\n            // We got a subscript start\n            if (subscript) {\n                throw new ParseError(\n                    \"Double subscript\", this.lexer, this.pos);\n            }\n            subscript = this.handleSupSubscript(\"subscript\");\n        } else if (lex.text === \"'\") {\n            // We got a prime\n            var prime = new ParseNode(\"textord\", \"\\\\prime\", this.mode);\n\n            // Many primes can be grouped together, so we handle this here\n            var primes = [prime];\n            this.consume();\n            // Keep lexing tokens until we get something that's not a prime\n            while (this.nextToken.text === \"'\") {\n                // For each one, add another prime to the list\n                primes.push(prime);\n                this.consume();\n            }\n            // Put them into an ordgroup as the superscript\n            superscript = new ParseNode(\"ordgroup\", primes, this.mode);\n        } else {\n            // If it wasn't ^, _, or ', stop parsing super/subscripts\n            break;\n        }\n    }\n\n    if (superscript || subscript) {\n        // If we got either a superscript or subscript, create a supsub\n        return new ParseNode(\"supsub\", {\n            base: base,\n            sup: superscript,\n            sub: subscript,\n        }, this.mode);\n    } else {\n        // Otherwise return the original body\n        return base;\n    }\n};\n\n// A list of the size-changing functions, for use in parseImplicitGroup\nvar sizeFuncs = [\n    \"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\",\n    \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\",\n];\n\n// A list of the style-changing functions, for use in parseImplicitGroup\nvar styleFuncs = [\n    \"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\",\n];\n\n/**\n * Parses an implicit group, which is a group that starts at the end of a\n * specified, and ends right before a higher explicit group ends, or at EOL. It\n * is used for functions that appear to affect the current style, like \\Large or\n * \\textrm, where instead of keeping a style we just pretend that there is an\n * implicit grouping after it until the end of the group. E.g.\n *   small text {\\Large large text} small text again\n * It is also used for \\left and \\right to get the correct grouping.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseImplicitGroup = function() {\n    var start = this.parseSymbol();\n\n    if (start == null) {\n        // If we didn't get anything we handle, fall back to parseFunction\n        return this.parseFunction();\n    }\n\n    var func = start.result;\n    var body;\n\n    if (func === \"\\\\left\") {\n        // If we see a left:\n        // Parse the entire left function (including the delimiter)\n        var left = this.parseFunction(start);\n        // Parse out the implicit body\n        body = this.parseExpression(false);\n        // Check the next token\n        this.expect(\"\\\\right\", false);\n        var right = this.parseFunction();\n        return new ParseNode(\"leftright\", {\n            body: body,\n            left: left.value.value,\n            right: right.value.value,\n        }, this.mode);\n    } else if (func === \"\\\\begin\") {\n        // begin...end is similar to left...right\n        var begin = this.parseFunction(start);\n        var envName = begin.value.name;\n        if (!environments.hasOwnProperty(envName)) {\n            throw new ParseError(\n                \"No such environment: \" + envName,\n                this.lexer, begin.value.namepos);\n        }\n        // Build the environment object. Arguments and other information will\n        // be made available to the begin and end methods using properties.\n        var env = environments[envName];\n        var args = this.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n        var context = {\n            mode: this.mode,\n            envName: envName,\n            parser: this,\n            lexer: this.lexer,\n            positions: args.pop(),\n        };\n        var result = env.handler(context, args);\n        this.expect(\"\\\\end\", false);\n        var end = this.parseFunction();\n        if (end.value.name !== envName) {\n            throw new ParseError(\n                \"Mismatch: \\\\begin{\" + envName + \"} matched \" +\n                \"by \\\\end{\" + end.value.name + \"}\",\n                this.lexer /* , end.value.namepos */);\n            // TODO: Add position to the above line and adjust test case,\n            // requires #385 to get merged first\n        }\n        result.position = end.position;\n        return result;\n    } else if (utils.contains(sizeFuncs, func)) {\n        // If we see a sizing function, parse out the implict body\n        body = this.parseExpression(false);\n        return new ParseNode(\"sizing\", {\n            // Figure out what size to use based on the list of functions above\n            size: \"size\" + (utils.indexOf(sizeFuncs, func) + 1),\n            value: body,\n        }, this.mode);\n    } else if (utils.contains(styleFuncs, func)) {\n        // If we see a styling function, parse out the implict body\n        body = this.parseExpression(true);\n        return new ParseNode(\"styling\", {\n            // Figure out what style to use by pulling out the style from\n            // the function name\n            style: func.slice(1, func.length - 5),\n            value: body,\n        }, this.mode);\n    } else {\n        // Defer to parseFunction if it's not a function we handle\n        return this.parseFunction(start);\n    }\n};\n\n/**\n * Parses an entire function, including its base and all of its arguments.\n * The base might either have been parsed already, in which case\n * it is provided as an argument, or it's the next group in the input.\n *\n * @param {ParseFuncOrArgument=} baseGroup optional as described above\n * @return {?ParseNode}\n */\nParser.prototype.parseFunction = function(baseGroup) {\n    if (!baseGroup) {\n        baseGroup = this.parseGroup();\n    }\n\n    if (baseGroup) {\n        if (baseGroup.isFunction) {\n            var func = baseGroup.result;\n            var funcData = functions[func];\n            if (this.mode === \"text\" && !funcData.allowedInText) {\n                throw new ParseError(\n                    \"Can't use function '\" + func + \"' in text mode\",\n                    this.lexer, baseGroup.position);\n            }\n\n            var args = this.parseArguments(func, funcData);\n            var result = this.callFunction(func, args, args.pop());\n            return new ParseNode(result.type, result, this.mode);\n        } else {\n            return baseGroup.result;\n        }\n    } else {\n        return null;\n    }\n};\n\n/**\n * Call a function handler with a suitable context and arguments.\n */\nParser.prototype.callFunction = function(name, args, positions) {\n    var context = {\n        funcName: name,\n        parser: this,\n        lexer: this.lexer,\n        positions: positions,\n    };\n    return functions[name].handler(context, args);\n};\n\n/**\n * Parses the arguments of a function or environment\n *\n * @param {string} func  \"\\name\" or \"\\begin{name}\"\n * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData\n * @return the array of arguments, with the list of positions as last element\n */\nParser.prototype.parseArguments = function(func, funcData) {\n    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n    if (totalArgs === 0) {\n        return [[this.pos]];\n    }\n\n    var baseGreediness = funcData.greediness;\n    var positions = [this.pos];\n    var args = [];\n\n    for (var i = 0; i < totalArgs; i++) {\n        var argType = funcData.argTypes && funcData.argTypes[i];\n        var arg;\n        if (i < funcData.numOptionalArgs) {\n            if (argType) {\n                arg = this.parseSpecialGroup(argType, true);\n            } else {\n                arg = this.parseOptionalGroup();\n            }\n            if (!arg) {\n                args.push(null);\n                positions.push(this.pos);\n                continue;\n            }\n        } else {\n            if (argType) {\n                arg = this.parseSpecialGroup(argType);\n            } else {\n                arg = this.parseGroup();\n            }\n            if (!arg) {\n                if (!this.settings.throwOnError &&\n                    this.nextToken.text[0] === \"\\\\\") {\n                    arg = new ParseFuncOrArgument(\n                        this.handleUnsupportedCmd(this.nextToken.text),\n                        false);\n                } else {\n                    throw new ParseError(\n                        \"Expected group after '\" + func + \"'\",\n                        this.lexer, this.pos);\n                }\n            }\n        }\n        var argNode;\n        if (arg.isFunction) {\n            var argGreediness =\n                functions[arg.result].greediness;\n            if (argGreediness > baseGreediness) {\n                argNode = this.parseFunction(arg);\n            } else {\n                throw new ParseError(\n                    \"Got function '\" + arg.result + \"' as \" +\n                    \"argument to '\" + func + \"'\",\n                    this.lexer, this.pos - 1);\n            }\n        } else {\n            argNode = arg.result;\n        }\n        args.push(argNode);\n        positions.push(this.pos);\n    }\n\n    args.push(positions);\n\n    return args;\n};\n\n\n/**\n * Parses a group when the mode is changing. Takes a position, a new mode, and\n * an outer mode that is used to parse the outside.\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSpecialGroup = function(innerMode, optional) {\n    var outerMode = this.mode;\n    // Handle `original` argTypes\n    if (innerMode === \"original\") {\n        innerMode = outerMode;\n    }\n\n    if (innerMode === \"color\" || innerMode === \"size\") {\n        // color and size modes are special because they should have braces and\n        // should only lex a single symbol inside\n        var openBrace = this.nextToken;\n        if (optional && openBrace.text !== \"[\") {\n            // optional arguments should return null if they don't exist\n            return null;\n        }\n        // The call to expect will lex the token after the '{' in inner mode\n        this.mode = innerMode;\n        this.expect(optional ? \"[\" : \"{\");\n        var inner = this.nextToken;\n        this.mode = outerMode;\n        var data;\n        if (innerMode === \"color\") {\n            data = inner.text;\n        } else {\n            data = inner.data;\n        }\n        this.consume(); // consume the token stored in inner\n        this.expect(optional ? \"]\" : \"}\");\n        return new ParseFuncOrArgument(\n            new ParseNode(innerMode, data, outerMode),\n            false);\n    } else if (innerMode === \"text\") {\n        // text mode is special because it should ignore the whitespace before\n        // it\n        var whitespace = this.lexer.lex(this.pos, \"whitespace\");\n        this.pos = whitespace.position;\n    }\n\n    // By the time we get here, innerMode is one of \"text\" or \"math\".\n    // We switch the mode of the parser, recurse, then restore the old mode.\n    this.mode = innerMode;\n    this.nextToken = this.lexer.lex(this.pos, innerMode);\n    var res;\n    if (optional) {\n        res = this.parseOptionalGroup();\n    } else {\n        res = this.parseGroup();\n    }\n    this.mode = outerMode;\n    this.nextToken = this.lexer.lex(this.pos, outerMode);\n    return res;\n};\n\n/**\n * Parses a group, which is either a single nucleus (like \"x\") or an expression\n * in braces (like \"{x+y}\")\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseGroup = function() {\n    // Try to parse an open brace\n    if (this.nextToken.text === \"{\") {\n        // If we get a brace, parse an expression\n        this.consume();\n        var expression = this.parseExpression(false);\n        // Make sure we get a close brace\n        this.expect(\"}\");\n        return new ParseFuncOrArgument(\n            new ParseNode(\"ordgroup\", expression, this.mode),\n            false);\n    } else {\n        // Otherwise, just return a nucleus\n        return this.parseSymbol();\n    }\n};\n\n/**\n * Parses a group, which is an expression in brackets (like \"[x+y]\")\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseOptionalGroup = function() {\n    // Try to parse an open bracket\n    if (this.nextToken.text === \"[\") {\n        // If we get a brace, parse an expression\n        this.consume();\n        var expression = this.parseExpression(false, \"]\");\n        // Make sure we get a close bracket\n        this.expect(\"]\");\n        return new ParseFuncOrArgument(\n            new ParseNode(\"ordgroup\", expression, this.mode),\n            false);\n    } else {\n        // Otherwise, return null,\n        return null;\n    }\n};\n\n/**\n * Parse a single symbol out of the string. Here, we handle both the functions\n * we have defined, as well as the single character symbols\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSymbol = function() {\n    var nucleus = this.nextToken;\n\n    if (functions[nucleus.text]) {\n        this.consume();\n        // If there exists a function with this name, we return the function and\n        // say that it is a function.\n        return new ParseFuncOrArgument(\n            nucleus.text,\n            true);\n    } else if (symbols[this.mode][nucleus.text]) {\n        this.consume();\n        // Otherwise if this is a no-argument function, find the type it\n        // corresponds to in the symbols map\n        return new ParseFuncOrArgument(\n            new ParseNode(symbols[this.mode][nucleus.text].group,\n                          nucleus.text, this.mode),\n            false);\n    } else {\n        return null;\n    }\n};\n\nParser.prototype.ParseNode = ParseNode;\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}