{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n/* eslint no-constant-condition:0 */\nvar fontMetrics = require(\"./fontMetrics\");\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\nvar ParseNode = parseData.ParseNode;\n\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.\n */\nfunction parseArray(parser, result) {\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n  while (true) {\n    var cell = parser.parseExpression(false, null);\n    row.push(new ParseNode(\"ordgroup\", cell, parser.mode));\n    var next = parser.nextToken.text;\n    if (next === \"&\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      break;\n    } else if (next === \"\\\\\\\\\" || next === \"\\\\cr\") {\n      var cr = parser.parseFunction();\n      rowGaps.push(cr.value.size);\n      row = [];\n      body.push(row);\n    } else {\n      // TODO: Clean up the following hack once #385 got merged\n      var pos = Math.min(parser.pos + 1, parser.lexer._input.length);\n      throw new ParseError(\"Expected & or \\\\\\\\ or \\\\end\", parser.lexer, pos);\n    }\n  }\n  result.body = body;\n  result.rowGaps = rowGaps;\n  return new ParseNode(result.type, result, parser.mode);\n}\n\n/*\n * An environment definition is very similar to a function definition:\n * it is declared with a name or a list of names, a set of properties\n * and a handler containing the actual implementation.\n *\n * The properties include:\n *  - numArgs: The number of arguments after the \\begin{name} function.\n *  - argTypes: (optional) Just like for a function\n *  - allowedInText: (optional) Whether or not the environment is allowed inside\n *                   text mode (default false) (not enforced yet)\n *  - numOptionalArgs: (optional) Just like for a function\n * A bare number instead of that object indicates the numArgs value.\n *\n * The handler function will receive two arguments\n *  - context: information and references provided by the parser\n *  - args: an array of arguments passed to \\begin{name}\n * The context contains the following properties:\n *  - envName: the name of the environment, one of the listed names.\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions associated with these arguments from args.\n * The handler must return a ParseResult.\n */\n\nfunction defineEnvironment(names, props, handler) {\n  if (typeof names === \"string\") {\n    names = [names];\n  }\n  if (typeof props === \"number\") {\n    props = {\n      numArgs: props\n    };\n  }\n  // Set default values of environments\n  var data = {\n    numArgs: props.numArgs || 0,\n    argTypes: props.argTypes,\n    greediness: 1,\n    allowedInText: !!props.allowedInText,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    handler: handler\n  };\n  for (var i = 0; i < names.length; ++i) {\n    module.exports[names[i]] = data;\n  }\n}\n\n// Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\ndefineEnvironment(\"array\", {\n  numArgs: 1\n}, function (context, args) {\n  var colalign = args[0];\n  colalign = colalign.value.map ? colalign.value : [colalign];\n  var cols = colalign.map(function (node) {\n    var ca = node.value;\n    if (\"lcr\".indexOf(ca) !== -1) {\n      return {\n        type: \"align\",\n        align: ca\n      };\n    } else if (ca === \"|\") {\n      return {\n        type: \"separator\",\n        separator: \"|\"\n      };\n    }\n    throw new ParseError(\"Unknown column alignment: \" + node.value, context.lexer, context.positions[1]);\n  });\n  var res = {\n    type: \"array\",\n    cols: cols,\n    hskipBeforeAndAfter: true // \\@preamble in lttab.dtx\n  };\n\n  res = parseArray(context.parser, res);\n  return res;\n});\n\n// The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\ndefineEnvironment([\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\"], {}, function (context) {\n  var delimiters = {\n    \"matrix\": null,\n    \"pmatrix\": [\"(\", \")\"],\n    \"bmatrix\": [\"[\", \"]\"],\n    \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n    \"vmatrix\": [\"|\", \"|\"],\n    \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n  }[context.envName];\n  var res = {\n    type: \"array\",\n    hskipBeforeAndAfter: false // \\hskip -\\arraycolsep in amsmath\n  };\n\n  res = parseArray(context.parser, res);\n  if (delimiters) {\n    res = new ParseNode(\"leftright\", {\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1]\n    }, context.mode);\n  }\n  return res;\n});\n\n// A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} … \\end{array}\\right.\ndefineEnvironment(\"cases\", {}, function (context) {\n  var res = {\n    type: \"array\",\n    arraystretch: 1.2,\n    cols: [{\n      type: \"align\",\n      align: \"l\",\n      pregap: 0,\n      postgap: fontMetrics.metrics.quad\n    }, {\n      type: \"align\",\n      align: \"l\",\n      pregap: 0,\n      postgap: 0\n    }]\n  };\n  res = parseArray(context.parser, res);\n  res = new ParseNode(\"leftright\", {\n    body: [res],\n    left: \"\\\\{\",\n    right: \".\"\n  }, context.mode);\n  return res;\n});\n\n// An aligned environment is like the align* environment\n// except it operates within math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\ndefineEnvironment(\"aligned\", {}, function (context) {\n  var res = {\n    type: \"array\",\n    cols: []\n  };\n  res = parseArray(context.parser, res);\n  var emptyGroup = new ParseNode(\"ordgroup\", [], context.mode);\n  var numCols = 0;\n  res.value.body.forEach(function (row) {\n    var i;\n    for (i = 1; i < row.length; i += 2) {\n      row[i].value.unshift(emptyGroup);\n    }\n    if (numCols < row.length) {\n      numCols = row.length;\n    }\n  });\n  for (var i = 0; i < numCols; ++i) {\n    var align = \"r\";\n    var pregap = 0;\n    if (i % 2 === 1) {\n      align = \"l\";\n    } else if (i > 0) {\n      pregap = 2; // one \\qquad between columns\n    }\n\n    res.value.cols[i] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n  return res;\n});","map":{"version":3,"names":["fontMetrics","require","parseData","ParseError","ParseNode","parseArray","parser","result","row","body","rowGaps","cell","parseExpression","push","mode","next","nextToken","text","consume","cr","parseFunction","value","size","pos","Math","min","lexer","_input","length","type","defineEnvironment","names","props","handler","numArgs","data","argTypes","greediness","allowedInText","numOptionalArgs","i","module","exports","context","args","colalign","map","cols","node","ca","indexOf","align","separator","positions","res","hskipBeforeAndAfter","delimiters","envName","left","right","arraystretch","pregap","postgap","metrics","quad","emptyGroup","numCols","forEach","unshift"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/fruitshop/node_modules/katex/src/environments.js"],"sourcesContent":["/* eslint no-constant-condition:0 */\nvar fontMetrics = require(\"./fontMetrics\");\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\n\nvar ParseNode = parseData.ParseNode;\n\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.\n */\nfunction parseArray(parser, result) {\n    var row = [];\n    var body = [row];\n    var rowGaps = [];\n    while (true) {\n        var cell = parser.parseExpression(false, null);\n        row.push(new ParseNode(\"ordgroup\", cell, parser.mode));\n        var next = parser.nextToken.text;\n        if (next === \"&\") {\n            parser.consume();\n        } else if (next === \"\\\\end\") {\n            break;\n        } else if (next === \"\\\\\\\\\" || next === \"\\\\cr\") {\n            var cr = parser.parseFunction();\n            rowGaps.push(cr.value.size);\n            row = [];\n            body.push(row);\n        } else {\n            // TODO: Clean up the following hack once #385 got merged\n            var pos = Math.min(parser.pos + 1, parser.lexer._input.length);\n            throw new ParseError(\"Expected & or \\\\\\\\ or \\\\end\",\n                                 parser.lexer, pos);\n        }\n    }\n    result.body = body;\n    result.rowGaps = rowGaps;\n    return new ParseNode(result.type, result, parser.mode);\n}\n\n/*\n * An environment definition is very similar to a function definition:\n * it is declared with a name or a list of names, a set of properties\n * and a handler containing the actual implementation.\n *\n * The properties include:\n *  - numArgs: The number of arguments after the \\begin{name} function.\n *  - argTypes: (optional) Just like for a function\n *  - allowedInText: (optional) Whether or not the environment is allowed inside\n *                   text mode (default false) (not enforced yet)\n *  - numOptionalArgs: (optional) Just like for a function\n * A bare number instead of that object indicates the numArgs value.\n *\n * The handler function will receive two arguments\n *  - context: information and references provided by the parser\n *  - args: an array of arguments passed to \\begin{name}\n * The context contains the following properties:\n *  - envName: the name of the environment, one of the listed names.\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions associated with these arguments from args.\n * The handler must return a ParseResult.\n */\n\nfunction defineEnvironment(names, props, handler) {\n    if (typeof names === \"string\") {\n        names = [names];\n    }\n    if (typeof props === \"number\") {\n        props = { numArgs: props };\n    }\n    // Set default values of environments\n    var data = {\n        numArgs: props.numArgs || 0,\n        argTypes: props.argTypes,\n        greediness: 1,\n        allowedInText: !!props.allowedInText,\n        numOptionalArgs: props.numOptionalArgs || 0,\n        handler: handler,\n    };\n    for (var i = 0; i < names.length; ++i) {\n        module.exports[names[i]] = data;\n    }\n}\n\n// Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\ndefineEnvironment(\"array\", {\n    numArgs: 1,\n}, function(context, args) {\n    var colalign = args[0];\n    colalign = colalign.value.map ? colalign.value : [colalign];\n    var cols = colalign.map(function(node) {\n        var ca = node.value;\n        if (\"lcr\".indexOf(ca) !== -1) {\n            return {\n                type: \"align\",\n                align: ca,\n            };\n        } else if (ca === \"|\") {\n            return {\n                type: \"separator\",\n                separator: \"|\",\n            };\n        }\n        throw new ParseError(\n            \"Unknown column alignment: \" + node.value,\n            context.lexer, context.positions[1]);\n    });\n    var res = {\n        type: \"array\",\n        cols: cols,\n        hskipBeforeAndAfter: true, // \\@preamble in lttab.dtx\n    };\n    res = parseArray(context.parser, res);\n    return res;\n});\n\n// The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\ndefineEnvironment([\n    \"matrix\",\n    \"pmatrix\",\n    \"bmatrix\",\n    \"Bmatrix\",\n    \"vmatrix\",\n    \"Vmatrix\",\n], {\n}, function(context) {\n    var delimiters = {\n        \"matrix\": null,\n        \"pmatrix\": [\"(\", \")\"],\n        \"bmatrix\": [\"[\", \"]\"],\n        \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n        \"vmatrix\": [\"|\", \"|\"],\n        \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"],\n    }[context.envName];\n    var res = {\n        type: \"array\",\n        hskipBeforeAndAfter: false, // \\hskip -\\arraycolsep in amsmath\n    };\n    res = parseArray(context.parser, res);\n    if (delimiters) {\n        res = new ParseNode(\"leftright\", {\n            body: [res],\n            left: delimiters[0],\n            right: delimiters[1],\n        }, context.mode);\n    }\n    return res;\n});\n\n// A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} … \\end{array}\\right.\ndefineEnvironment(\"cases\", {\n}, function(context) {\n    var res = {\n        type: \"array\",\n        arraystretch: 1.2,\n        cols: [{\n            type: \"align\",\n            align: \"l\",\n            pregap: 0,\n            postgap: fontMetrics.metrics.quad,\n        }, {\n            type: \"align\",\n            align: \"l\",\n            pregap: 0,\n            postgap: 0,\n        }],\n    };\n    res = parseArray(context.parser, res);\n    res = new ParseNode(\"leftright\", {\n        body: [res],\n        left: \"\\\\{\",\n        right: \".\",\n    }, context.mode);\n    return res;\n});\n\n// An aligned environment is like the align* environment\n// except it operates within math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\ndefineEnvironment(\"aligned\", {\n}, function(context) {\n    var res = {\n        type: \"array\",\n        cols: [],\n    };\n    res = parseArray(context.parser, res);\n    var emptyGroup = new ParseNode(\"ordgroup\", [], context.mode);\n    var numCols = 0;\n    res.value.body.forEach(function(row) {\n        var i;\n        for (i = 1; i < row.length; i += 2) {\n            row[i].value.unshift(emptyGroup);\n        }\n        if (numCols < row.length) {\n            numCols = row.length;\n        }\n    });\n    for (var i = 0; i < numCols; ++i) {\n        var align = \"r\";\n        var pregap = 0;\n        if (i % 2 === 1) {\n            align = \"l\";\n        } else if (i > 0) {\n            pregap = 2; // one \\qquad between columns\n        }\n        res.value.cols[i] = {\n            type: \"align\",\n            align: align,\n            pregap: pregap,\n            postgap: 0,\n        };\n    }\n    return res;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}