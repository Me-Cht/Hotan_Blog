{"ast":null,"code":"// Process *this* and _that_\n//\n'use strict';\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i,\n    scanned,\n    token,\n    start = state.pos,\n    marker = state.src.charCodeAt(start);\n  if (silent) {\n    return false;\n  }\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {\n    return false;\n  }\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n  for (i = 0; i < scanned.length; i++) {\n    token = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump: i,\n      // A position of the token this delimiter corresponds to.\n      //\n      token: state.tokens.length - 1,\n      // Token level.\n      //\n      level: state.level,\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end: -1,\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open: scanned.can_open,\n      close: scanned.can_close\n    });\n  }\n  state.pos += scanned.length;\n  return true;\n};\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var i,\n    startDelim,\n    endDelim,\n    token,\n    ch,\n    isStrong,\n    delimiters = state.delimiters,\n    max = state.delimiters.length;\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n    endDelim = delimiters[startDelim.end];\n\n    // If the next delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;\n    ch = String.fromCharCode(startDelim.marker);\n    token = state.tokens[startDelim.token];\n    token.type = isStrong ? 'strong_open' : 'em_open';\n    token.tag = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup = isStrong ? ch + ch : ch;\n    token.content = '';\n    token = state.tokens[endDelim.token];\n    token.type = isStrong ? 'strong_close' : 'em_close';\n    token.tag = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup = isStrong ? ch + ch : ch;\n    token.content = '';\n    if (isStrong) {\n      state.tokens[delimiters[i + 1].token].content = '';\n      state.tokens[delimiters[startDelim.end - 1].token].content = '';\n      i++;\n    }\n  }\n};","map":{"version":3,"names":["require","module","exports","tokenize","emphasis","state","silent","i","scanned","token","start","pos","marker","src","charCodeAt","scanDelims","length","push","content","String","fromCharCode","delimiters","jump","tokens","level","end","open","can_open","close","can_close","postProcess","startDelim","endDelim","ch","isStrong","max","type","tag","nesting","markup"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/fruitshop/node_modules/markdown-it/lib/rules_inline/emphasis.js"],"sourcesContent":["// Process *this* and _that_\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // Token level.\n      //\n      level:  state.level,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the next delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i + 1 < max &&\n               delimiters[i + 1].end === startDelim.end - 1 &&\n               delimiters[i + 1].token === startDelim.token + 1 &&\n               delimiters[startDelim.end - 1].token === endDelim.token - 1 &&\n               delimiters[i + 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i + 1].token].content = '';\n      state.tokens[delimiters[startDelim.end - 1].token].content = '';\n      i++;\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}