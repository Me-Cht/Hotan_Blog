{"ast":null,"code":"/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work simlarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\n\nvar utils = require(\"./utils\");\n\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\nfunction MathNode(type, children) {\n  this.type = type;\n  this.attributes = {};\n  this.children = children || [];\n}\n\n/**\n * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n * semantic content, so this is used heavily.\n */\nMathNode.prototype.setAttribute = function (name, value) {\n  this.attributes[name] = value;\n};\n\n/**\n * Converts the math node into a MathML-namespaced DOM element.\n */\nMathNode.prototype.toNode = function () {\n  var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  }\n  for (var i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n  return node;\n};\n\n/**\n * Converts the math node into an HTML markup string.\n */\nMathNode.prototype.toMarkup = function () {\n  var markup = \"<\" + this.type;\n\n  // Add the attributes\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      markup += \" \" + attr + \"=\\\"\";\n      markup += utils.escape(this.attributes[attr]);\n      markup += \"\\\"\";\n    }\n  }\n  markup += \">\";\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n  markup += \"</\" + this.type + \">\";\n  return markup;\n};\n\n/**\n * This node represents a piece of text.\n */\nfunction TextNode(text) {\n  this.text = text;\n}\n\n/**\n * Converts the text node into a DOM text node.\n */\nTextNode.prototype.toNode = function () {\n  return document.createTextNode(this.text);\n};\n\n/**\n * Converts the text node into HTML markup (which is just the text itself).\n */\nTextNode.prototype.toMarkup = function () {\n  return utils.escape(this.text);\n};\nmodule.exports = {\n  MathNode: MathNode,\n  TextNode: TextNode\n};","map":{"version":3,"names":["utils","require","MathNode","type","children","attributes","prototype","setAttribute","name","value","toNode","node","document","createElementNS","attr","Object","hasOwnProperty","call","i","length","appendChild","toMarkup","markup","escape","TextNode","text","createTextNode","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/katex/src/mathMLTree.js"],"sourcesContent":["/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work simlarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\n\nvar utils = require(\"./utils\");\n\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\nfunction MathNode(type, children) {\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n}\n\n/**\n * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n * semantic content, so this is used heavily.\n */\nMathNode.prototype.setAttribute = function(name, value) {\n    this.attributes[name] = value;\n};\n\n/**\n * Converts the math node into a MathML-namespaced DOM element.\n */\nMathNode.prototype.toNode = function() {\n    var node = document.createElementNS(\n        \"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            node.setAttribute(attr, this.attributes[attr]);\n        }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n        node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n};\n\n/**\n * Converts the math node into an HTML markup string.\n */\nMathNode.prototype.toMarkup = function() {\n    var markup = \"<\" + this.type;\n\n    // Add the attributes\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            markup += \" \" + attr + \"=\\\"\";\n            markup += utils.escape(this.attributes[attr]);\n            markup += \"\\\"\";\n        }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n\n    return markup;\n};\n\n/**\n * This node represents a piece of text.\n */\nfunction TextNode(text) {\n    this.text = text;\n}\n\n/**\n * Converts the text node into a DOM text node.\n */\nTextNode.prototype.toNode = function() {\n    return document.createTextNode(this.text);\n};\n\n/**\n * Converts the text node into HTML markup (which is just the text itself).\n */\nTextNode.prototype.toMarkup = function() {\n    return utils.escape(this.text);\n};\n\nmodule.exports = {\n    MathNode: MathNode,\n    TextNode: TextNode,\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAS,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA,SAASC,QAAQA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC9B,IAAI,CAACD,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACE,UAAU,GAAG,CAAC,CAAC;EACpB,IAAI,CAACD,QAAQ,GAAGA,QAAQ,IAAI,EAAE;AAClC;;AAEA;AACA;AACA;AACA;AACAF,QAAQ,CAACI,SAAS,CAACC,YAAY,GAAG,UAASC,IAAI,EAAEC,KAAK,EAAE;EACpD,IAAI,CAACJ,UAAU,CAACG,IAAI,CAAC,GAAGC,KAAK;AACjC,CAAC;;AAED;AACA;AACA;AACAP,QAAQ,CAACI,SAAS,CAACI,MAAM,GAAG,YAAW;EACnC,IAAIC,IAAI,GAAGC,QAAQ,CAACC,eAAe,CAC/B,oCAAoC,EAAE,IAAI,CAACV,IAAI,CAAC;EAEpD,KAAK,IAAIW,IAAI,IAAI,IAAI,CAACT,UAAU,EAAE;IAC9B,IAAIU,MAAM,CAACT,SAAS,CAACU,cAAc,CAACC,IAAI,CAAC,IAAI,CAACZ,UAAU,EAAES,IAAI,CAAC,EAAE;MAC7DH,IAAI,CAACJ,YAAY,CAACO,IAAI,EAAE,IAAI,CAACT,UAAU,CAACS,IAAI,CAAC,CAAC;IAClD;EACJ;EAEA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACd,QAAQ,CAACe,MAAM,EAAED,CAAC,EAAE,EAAE;IAC3CP,IAAI,CAACS,WAAW,CAAC,IAAI,CAAChB,QAAQ,CAACc,CAAC,CAAC,CAACR,MAAM,EAAE,CAAC;EAC/C;EAEA,OAAOC,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACAT,QAAQ,CAACI,SAAS,CAACe,QAAQ,GAAG,YAAW;EACrC,IAAIC,MAAM,GAAG,GAAG,GAAG,IAAI,CAACnB,IAAI;;EAE5B;EACA,KAAK,IAAIW,IAAI,IAAI,IAAI,CAACT,UAAU,EAAE;IAC9B,IAAIU,MAAM,CAACT,SAAS,CAACU,cAAc,CAACC,IAAI,CAAC,IAAI,CAACZ,UAAU,EAAES,IAAI,CAAC,EAAE;MAC7DQ,MAAM,IAAI,GAAG,GAAGR,IAAI,GAAG,KAAK;MAC5BQ,MAAM,IAAItB,KAAK,CAACuB,MAAM,CAAC,IAAI,CAAClB,UAAU,CAACS,IAAI,CAAC,CAAC;MAC7CQ,MAAM,IAAI,IAAI;IAClB;EACJ;EAEAA,MAAM,IAAI,GAAG;EAEb,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACd,QAAQ,CAACe,MAAM,EAAED,CAAC,EAAE,EAAE;IAC3CI,MAAM,IAAI,IAAI,CAAClB,QAAQ,CAACc,CAAC,CAAC,CAACG,QAAQ,EAAE;EACzC;EAEAC,MAAM,IAAI,IAAI,GAAG,IAAI,CAACnB,IAAI,GAAG,GAAG;EAEhC,OAAOmB,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA,SAASE,QAAQA,CAACC,IAAI,EAAE;EACpB,IAAI,CAACA,IAAI,GAAGA,IAAI;AACpB;;AAEA;AACA;AACA;AACAD,QAAQ,CAAClB,SAAS,CAACI,MAAM,GAAG,YAAW;EACnC,OAAOE,QAAQ,CAACc,cAAc,CAAC,IAAI,CAACD,IAAI,CAAC;AAC7C,CAAC;;AAED;AACA;AACA;AACAD,QAAQ,CAAClB,SAAS,CAACe,QAAQ,GAAG,YAAW;EACrC,OAAOrB,KAAK,CAACuB,MAAM,CAAC,IAAI,CAACE,IAAI,CAAC;AAClC,CAAC;AAEDE,MAAM,CAACC,OAAO,GAAG;EACb1B,QAAQ,EAAEA,QAAQ;EAClBsB,QAAQ,EAAEA;AACd,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}