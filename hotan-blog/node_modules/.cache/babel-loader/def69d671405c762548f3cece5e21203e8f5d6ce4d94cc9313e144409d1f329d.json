{"ast":null,"code":"'use strict';\n\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle = require('../helpers/parse_link_title');\nvar normalizeReference = require('../common/utils').normalizeReference;\nvar isSpace = require('../common/utils').isSpace;\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n    destEndPos,\n    destEndLineNo,\n    endLine,\n    href,\n    i,\n    l,\n    label,\n    labelEnd,\n    res,\n    start,\n    str,\n    terminate,\n    terminatorRules,\n    title,\n    lines = 0,\n    pos = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine],\n    nextLine = startLine + 1;\n  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {\n    return false;\n  }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \\ */) {\n      if (pos + 1 === max) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {\n        return false;\n      }\n      break;\n    }\n  }\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {\n    return false;\n  }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = parseLinkDestination(str, pos, max);\n  if (!res.ok) {\n    return false;\n  }\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      break;\n    }\n    pos++;\n  }\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n        pos++;\n      }\n    }\n  }\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) {\n    return true;\n  }\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n  state.line = startLine + lines + 1;\n  return true;\n};","map":{"version":3,"names":["parseLinkDestination","require","parseLinkTitle","normalizeReference","isSpace","module","exports","reference","state","startLine","_endLine","silent","ch","destEndPos","destEndLineNo","endLine","href","i","l","label","labelEnd","res","start","str","terminate","terminatorRules","title","lines","pos","bMarks","tShift","max","eMarks","nextLine","src","charCodeAt","lineMax","md","block","ruler","getRules","isEmpty","sCount","blkIndent","length","getLines","trim","ok","normalizeLink","validateLink","slice","env","references","line"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/markdown-it/lib/rules_block/reference.js"],"sourcesContent":["'use strict';\n\n\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}