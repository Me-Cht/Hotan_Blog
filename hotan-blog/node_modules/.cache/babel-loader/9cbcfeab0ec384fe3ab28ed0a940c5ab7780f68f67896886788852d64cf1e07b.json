{"ast":null,"code":"// Paragraph\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports = function paragraph(state, startLine /*, endLine*/) {\n  var content,\n    terminate,\n    i,\n    l,\n    token,\n    nextLine = startLine + 1,\n    terminatorRules = state.md.block.ruler.getRules('paragraph'),\n    endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n  token = state.push('paragraph_open', 'p', 1);\n  token.map = [startLine, state.line];\n  token = state.push('inline', '', 0);\n  token.content = content;\n  token.map = [startLine, state.line];\n  token.children = [];\n  token = state.push('paragraph_close', 'p', -1);\n  return true;\n};","map":{"version":3,"names":["require","module","exports","paragraph","state","startLine","content","terminate","i","l","token","nextLine","terminatorRules","md","block","ruler","getRules","endLine","lineMax","isEmpty","sCount","blkIndent","length","getLines","trim","line","push","map","children"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/fruitshop/node_modules/markdown-it/lib/rules_block/paragraph.js"],"sourcesContent":["// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  return true;\n};\n"],"mappings":"AAAA;;AAEA,YAAY;;AAACA,OAAA;AAGbC,MAAM,CAACC,OAAO,GAAG,SAASC,SAASA,CAACC,KAAK,EAAEC,SAAS,gBAAe;EACjE,IAAIC,OAAO;IAAEC,SAAS;IAAEC,CAAC;IAAEC,CAAC;IAAEC,KAAK;IAC/BC,QAAQ,GAAGN,SAAS,GAAG,CAAC;IACxBO,eAAe,GAAGR,KAAK,CAACS,EAAE,CAACC,KAAK,CAACC,KAAK,CAACC,QAAQ,CAAC,WAAW,CAAC;IAC5DC,OAAO,GAAGb,KAAK,CAACc,OAAO;;EAE3B;EACA,OAAOP,QAAQ,GAAGM,OAAO,IAAI,CAACb,KAAK,CAACe,OAAO,CAACR,QAAQ,CAAC,EAAEA,QAAQ,EAAE,EAAE;IACjE;IACA;IACA,IAAIP,KAAK,CAACgB,MAAM,CAACT,QAAQ,CAAC,GAAGP,KAAK,CAACiB,SAAS,GAAG,CAAC,EAAE;MAAE;IAAU;;IAE9D;IACA,IAAIjB,KAAK,CAACgB,MAAM,CAACT,QAAQ,CAAC,GAAG,CAAC,EAAE;MAAE;IAAU;;IAE5C;IACAJ,SAAS,GAAG,KAAK;IACjB,KAAKC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGG,eAAe,CAACU,MAAM,EAAEd,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAClD,IAAII,eAAe,CAACJ,CAAC,CAAC,CAACJ,KAAK,EAAEO,QAAQ,EAAEM,OAAO,EAAE,IAAI,CAAC,EAAE;QACtDV,SAAS,GAAG,IAAI;QAChB;MACF;IACF;IACA,IAAIA,SAAS,EAAE;MAAE;IAAO;EAC1B;EAEAD,OAAO,GAAGF,KAAK,CAACmB,QAAQ,CAAClB,SAAS,EAAEM,QAAQ,EAAEP,KAAK,CAACiB,SAAS,EAAE,KAAK,CAAC,CAACG,IAAI,EAAE;EAE5EpB,KAAK,CAACqB,IAAI,GAAGd,QAAQ;EAErBD,KAAK,GAAYN,KAAK,CAACsB,IAAI,CAAC,gBAAgB,EAAE,GAAG,EAAE,CAAC,CAAC;EACrDhB,KAAK,CAACiB,GAAG,GAAQ,CAAEtB,SAAS,EAAED,KAAK,CAACqB,IAAI,CAAE;EAE1Cf,KAAK,GAAYN,KAAK,CAACsB,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;EAC5ChB,KAAK,CAACJ,OAAO,GAAIA,OAAO;EACxBI,KAAK,CAACiB,GAAG,GAAQ,CAAEtB,SAAS,EAAED,KAAK,CAACqB,IAAI,CAAE;EAC1Cf,KAAK,CAACkB,QAAQ,GAAG,EAAE;EAEnBlB,KAAK,GAAYN,KAAK,CAACsB,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;EAEvD,OAAO,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}