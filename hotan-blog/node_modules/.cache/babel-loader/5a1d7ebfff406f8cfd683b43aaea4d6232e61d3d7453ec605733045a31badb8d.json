{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i,\n      scanned,\n      token,\n      len,\n      ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n    if (silent) {\n      return false;\n    }\n    if (marker !== 0x2B /* + */) {\n      return false;\n    }\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n    if (len < 2) {\n      return false;\n    }\n    if (len % 2) {\n      token = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n    for (i = 0; i < len; i += 2) {\n      token = state.push('text', '', 0);\n      token.content = ch + ch;\n      state.delimiters.push({\n        marker: marker,\n        jump: i,\n        token: state.tokens.length - 1,\n        level: state.level,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close\n      });\n    }\n    state.pos += scanned.length;\n    return true;\n  }\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess(state) {\n    var i,\n      j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n      if (startDelim.marker !== 0x2B /* + */) {\n        continue;\n      }\n      if (startDelim.end === -1) {\n        continue;\n      }\n      endDelim = delimiters[startDelim.end];\n      token = state.tokens[startDelim.token];\n      token.type = 'ins_open';\n      token.tag = 'ins';\n      token.nesting = 1;\n      token.markup = '++';\n      token.content = '';\n      token = state.tokens[endDelim.token];\n      token.type = 'ins_close';\n      token.tag = 'ins';\n      token.nesting = -1;\n      token.markup = '++';\n      token.content = '';\n      if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '+') {\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n      while (j < state.tokens.length && state.tokens[j].type === 'ins_close') {\n        j++;\n      }\n      j--;\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n  md.inline.ruler.before('emphasis', 'ins', tokenize);\n  md.inline.ruler2.before('emphasis', 'ins', postProcess);\n};","map":{"version":3,"names":["require","module","exports","ins_plugin","md","tokenize","state","silent","i","scanned","token","len","ch","start","pos","marker","src","charCodeAt","scanDelims","length","String","fromCharCode","push","content","delimiters","jump","tokens","level","end","open","can_open","close","can_close","postProcess","j","startDelim","endDelim","loneMarkers","max","type","tag","nesting","markup","pop","inline","ruler","before","ruler2"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/markdown-it-ins/index.js"],"sourcesContent":["'use strict';\n\n\nmodule.exports = function ins_plugin(md) {\n  // Insert each marker as a separate text token, and add it to delimiter list\n  //\n  function tokenize(state, silent) {\n    var i, scanned, token, len, ch,\n        start = state.pos,\n        marker = state.src.charCodeAt(start);\n\n    if (silent) { return false; }\n\n    if (marker !== 0x2B/* + */) { return false; }\n\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n\n    if (len < 2) { return false; }\n\n    if (len % 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch;\n      len--;\n    }\n\n    for (i = 0; i < len; i += 2) {\n      token         = state.push('text', '', 0);\n      token.content = ch + ch;\n\n      state.delimiters.push({\n        marker: marker,\n        jump:   i,\n        token:  state.tokens.length - 1,\n        level:  state.level,\n        end:    -1,\n        open:   scanned.can_open,\n        close:  scanned.can_close\n      });\n    }\n\n    state.pos += scanned.length;\n\n    return true;\n  }\n\n\n  // Walk through delimiter list and replace text tokens with tags\n  //\n  function postProcess(state) {\n    var i, j,\n        startDelim,\n        endDelim,\n        token,\n        loneMarkers = [],\n        delimiters = state.delimiters,\n        max = state.delimiters.length;\n\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n\n      if (startDelim.marker !== 0x2B/* + */) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n\n      token         = state.tokens[startDelim.token];\n      token.type    = 'ins_open';\n      token.tag     = 'ins';\n      token.nesting = 1;\n      token.markup  = '++';\n      token.content = '';\n\n      token         = state.tokens[endDelim.token];\n      token.type    = 'ins_close';\n      token.tag     = 'ins';\n      token.nesting = -1;\n      token.markup  = '++';\n      token.content = '';\n\n      if (state.tokens[endDelim.token - 1].type === 'text' &&\n          state.tokens[endDelim.token - 1].content === '+') {\n\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    //\n    // So, we have to move all those markers after subsequent s_close tags.\n    //\n    while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n\n      while (j < state.tokens.length && state.tokens[j].type === 'ins_close') {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n\n  md.inline.ruler.before('emphasis', 'ins', tokenize);\n  md.inline.ruler2.before('emphasis', 'ins', postProcess);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}