{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n/**\n * This file converts a parse tree into a cooresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\nvar buildCommon = require(\"./buildCommon\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar mathMLTree = require(\"./mathMLTree\");\nvar ParseError = require(\"./ParseError\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\nvar makeSpan = buildCommon.makeSpan;\nvar fontMap = buildCommon.fontMap;\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar makeText = function (text, mode) {\n  if (symbols[mode][text] && symbols[mode][text].replace) {\n    text = symbols[mode][text].replace;\n  }\n  return new mathMLTree.TextNode(text);\n};\n\n/**\n * Returns the math variant as a string or null if none is required.\n */\nvar getVariant = function (group, options) {\n  var font = options.font;\n  if (!font) {\n    return null;\n  }\n  var mode = group.mode;\n  if (font === \"mathit\") {\n    return \"italic\";\n  }\n  var value = group.value;\n  if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], value)) {\n    return null;\n  }\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n  var fontName = fontMap[font].fontName;\n  if (fontMetrics.getCharacterMetrics(value, fontName)) {\n    return fontMap[options.font].variant;\n  }\n  return null;\n};\n\n/**\n * Functions for handling the different types of groups found in the parse\n * tree. Each function should take a parse group and return a MathML node.\n */\nvar groupTypes = {};\ngroupTypes.mathord = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mi\", [makeText(group.value, group.mode)]);\n  var variant = getVariant(group, options);\n  if (variant) {\n    node.setAttribute(\"mathvariant\", variant);\n  }\n  return node;\n};\ngroupTypes.textord = function (group, options) {\n  var text = makeText(group.value, group.mode);\n  var variant = getVariant(group, options) || \"normal\";\n  var node;\n  if (/[0-9]/.test(group.value)) {\n    // TODO(kevinb) merge adjacent <mn> nodes\n    // do it as a post processing step\n    node = new mathMLTree.MathNode(\"mn\", [text]);\n    if (options.font) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n  } else {\n    node = new mathMLTree.MathNode(\"mi\", [text]);\n    node.setAttribute(\"mathvariant\", variant);\n  }\n  return node;\n};\ngroupTypes.bin = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\ngroupTypes.rel = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\ngroupTypes.open = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\ngroupTypes.close = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\ngroupTypes.inner = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\ngroupTypes.punct = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  node.setAttribute(\"separator\", \"true\");\n  return node;\n};\ngroupTypes.ordgroup = function (group, options) {\n  var inner = buildExpression(group.value, options);\n  var node = new mathMLTree.MathNode(\"mrow\", inner);\n  return node;\n};\ngroupTypes.text = function (group, options) {\n  var inner = buildExpression(group.value.body, options);\n  var node = new mathMLTree.MathNode(\"mtext\", inner);\n  return node;\n};\ngroupTypes.color = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.value.color);\n  return node;\n};\ngroupTypes.supsub = function (group, options) {\n  var children = [buildGroup(group.value.base, options)];\n  if (group.value.sub) {\n    children.push(buildGroup(group.value.sub, options));\n  }\n  if (group.value.sup) {\n    children.push(buildGroup(group.value.sup, options));\n  }\n  var nodeType;\n  if (!group.value.sub) {\n    nodeType = \"msup\";\n  } else if (!group.value.sup) {\n    nodeType = \"msub\";\n  } else {\n    nodeType = \"msubsup\";\n  }\n  var node = new mathMLTree.MathNode(nodeType, children);\n  return node;\n};\ngroupTypes.genfrac = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mfrac\", [buildGroup(group.value.numer, options), buildGroup(group.value.denom, options)]);\n  if (!group.value.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  }\n  if (group.value.leftDelim != null || group.value.rightDelim != null) {\n    var withDelims = [];\n    if (group.value.leftDelim != null) {\n      var leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.value.leftDelim)]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n    withDelims.push(node);\n    if (group.value.rightDelim != null) {\n      var rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.value.rightDelim)]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n    var outerNode = new mathMLTree.MathNode(\"mrow\", withDelims);\n    return outerNode;\n  }\n  return node;\n};\ngroupTypes.array = function (group, options) {\n  return new mathMLTree.MathNode(\"mtable\", group.value.body.map(function (row) {\n    return new mathMLTree.MathNode(\"mtr\", row.map(function (cell) {\n      return new mathMLTree.MathNode(\"mtd\", [buildGroup(cell, options)]);\n    }));\n  }));\n};\ngroupTypes.sqrt = function (group, options) {\n  var node;\n  if (group.value.index) {\n    node = new mathMLTree.MathNode(\"mroot\", [buildGroup(group.value.body, options), buildGroup(group.value.index, options)]);\n  } else {\n    node = new mathMLTree.MathNode(\"msqrt\", [buildGroup(group.value.body, options)]);\n  }\n  return node;\n};\ngroupTypes.leftright = function (group, options) {\n  var inner = buildExpression(group.value.body, options);\n  if (group.value.left !== \".\") {\n    var leftNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.left, group.mode)]);\n    leftNode.setAttribute(\"fence\", \"true\");\n    inner.unshift(leftNode);\n  }\n  if (group.value.right !== \".\") {\n    var rightNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.right, group.mode)]);\n    rightNode.setAttribute(\"fence\", \"true\");\n    inner.push(rightNode);\n  }\n  var outerNode = new mathMLTree.MathNode(\"mrow\", inner);\n  return outerNode;\n};\ngroupTypes.accent = function (group, options) {\n  var accentNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.accent, group.mode)]);\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.value.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\ngroupTypes.spacing = function (group) {\n  var node;\n  if (group.value === \"\\\\ \" || group.value === \"\\\\space\" || group.value === \" \" || group.value === \"~\") {\n    node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n  } else {\n    node = new mathMLTree.MathNode(\"mspace\");\n    node.setAttribute(\"width\", buildCommon.spacingFunctions[group.value].size);\n  }\n  return node;\n};\ngroupTypes.op = function (group) {\n  var node;\n\n  // TODO(emily): handle big operators using the `largeop` attribute\n\n  if (group.value.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new mathMLTree.MathNode(\"mo\", [makeText(group.value.body, group.mode)]);\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    // TODO(emily): Add a space in the middle of some of these\n    // operators, like \\limsup.\n    node = new mathMLTree.MathNode(\"mi\", [new mathMLTree.TextNode(group.value.body.slice(1))]);\n  }\n  return node;\n};\ngroupTypes.katex = function (group) {\n  var node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"KaTeX\")]);\n  return node;\n};\ngroupTypes.font = function (group, options) {\n  var font = group.value.font;\n  return buildGroup(group.value.body, options.withFont(font));\n};\ngroupTypes.delimsizing = function (group) {\n  var children = [];\n  if (group.value.value !== \".\") {\n    children.push(makeText(group.value.value, group.mode));\n  }\n  var node = new mathMLTree.MathNode(\"mo\", children);\n  if (group.value.delimType === \"open\" || group.value.delimType === \"close\") {\n    // Only some of the delimsizing functions act as fences, and they\n    // return \"open\" or \"close\" delimTypes.\n    node.setAttribute(\"fence\", \"true\");\n  } else {\n    // Explicitly disable fencing if it's not a fence, to override the\n    // defaults.\n    node.setAttribute(\"fence\", \"false\");\n  }\n  return node;\n};\ngroupTypes.styling = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  var styleAttributes = {\n    \"display\": [\"0\", \"true\"],\n    \"text\": [\"0\", \"false\"],\n    \"script\": [\"1\", \"false\"],\n    \"scriptscript\": [\"2\", \"false\"]\n  };\n  var attr = styleAttributes[group.value.style];\n  node.setAttribute(\"scriptlevel\", attr[0]);\n  node.setAttribute(\"displaystyle\", attr[1]);\n  return node;\n};\ngroupTypes.sizing = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n  // TODO(emily): This doesn't produce the correct size for nested size\n  // changes, because we don't keep state of what style we're currently\n  // in, so we can't reset the size to normal before changing it.  Now\n  // that we're passing an options parameter we should be able to fix\n  // this.\n  node.setAttribute(\"mathsize\", buildCommon.sizingMultiplier[group.value.size] + \"em\");\n  return node;\n};\ngroupTypes.overline = function (group, options) {\n  var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n  operator.setAttribute(\"stretchy\", \"true\");\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.value.body, options), operator]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\ngroupTypes.underline = function (group, options) {\n  var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n  operator.setAttribute(\"stretchy\", \"true\");\n  var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.value.body, options), operator]);\n  node.setAttribute(\"accentunder\", \"true\");\n  return node;\n};\ngroupTypes.rule = function (group) {\n  // TODO(emily): Figure out if there's an actual way to draw black boxes\n  // in MathML.\n  var node = new mathMLTree.MathNode(\"mrow\");\n  return node;\n};\ngroupTypes.llap = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.value.body, options)]);\n  node.setAttribute(\"lspace\", \"-1width\");\n  node.setAttribute(\"width\", \"0px\");\n  return node;\n};\ngroupTypes.rlap = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.value.body, options)]);\n  node.setAttribute(\"width\", \"0px\");\n  return node;\n};\ngroupTypes.phantom = function (group, options, prev) {\n  var inner = buildExpression(group.value.value, options);\n  return new mathMLTree.MathNode(\"mphantom\", inner);\n};\n\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes. A little simpler than the HTML version because we don't do any\n * previous-node handling.\n */\nvar buildExpression = function (expression, options) {\n  var groups = [];\n  for (var i = 0; i < expression.length; i++) {\n    var group = expression[i];\n    groups.push(buildGroup(group, options));\n  }\n  return groups;\n};\n\n/**\n * Takes a group from the parser and calls the appropriate groupTypes function\n * on it to produce a MathML node.\n */\nvar buildGroup = function (group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n  if (groupTypes[group.type]) {\n    // Call the groupTypes function\n    return groupTypes[group.type](group, options);\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\nvar buildMathML = function (tree, texExpression, options) {\n  var expression = buildExpression(tree, options);\n\n  // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly.\n  var wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n\n  // Build a TeX annotation of the source\n  var annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  var semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  var math = new mathMLTree.MathNode(\"math\", [semantics]);\n\n  // You can't style <math> nodes, so we wrap the node in a span.\n  return makeSpan([\"katex-mathml\"], [math]);\n};\nmodule.exports = buildMathML;","map":{"version":3,"names":["buildCommon","require","fontMetrics","mathMLTree","ParseError","symbols","utils","makeSpan","fontMap","makeText","text","mode","replace","TextNode","getVariant","group","options","font","value","contains","fontName","getCharacterMetrics","variant","groupTypes","mathord","node","MathNode","setAttribute","textord","test","bin","rel","open","close","inner","punct","ordgroup","buildExpression","body","color","supsub","children","buildGroup","base","sub","push","sup","nodeType","genfrac","numer","denom","hasBarLine","leftDelim","rightDelim","withDelims","leftOp","rightOp","outerNode","array","map","row","cell","sqrt","index","leftright","left","leftNode","unshift","right","rightNode","accent","accentNode","spacing","spacingFunctions","size","op","symbol","slice","katex","withFont","delimsizing","delimType","styling","styleAttributes","attr","style","sizing","sizingMultiplier","overline","operator","underline","rule","llap","rlap","phantom","prev","expression","groups","i","length","type","buildMathML","tree","texExpression","wrapper","annotation","semantics","math","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/katex/src/buildMathML.js"],"sourcesContent":["/**\n * This file converts a parse tree into a cooresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\nvar buildCommon = require(\"./buildCommon\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar mathMLTree = require(\"./mathMLTree\");\nvar ParseError = require(\"./ParseError\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\n\nvar makeSpan = buildCommon.makeSpan;\nvar fontMap = buildCommon.fontMap;\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar makeText = function(text, mode) {\n    if (symbols[mode][text] && symbols[mode][text].replace) {\n        text = symbols[mode][text].replace;\n    }\n\n    return new mathMLTree.TextNode(text);\n};\n\n/**\n * Returns the math variant as a string or null if none is required.\n */\nvar getVariant = function(group, options) {\n    var font = options.font;\n    if (!font) {\n        return null;\n    }\n\n    var mode = group.mode;\n    if (font === \"mathit\") {\n        return \"italic\";\n    }\n\n    var value = group.value;\n    if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], value)) {\n        return null;\n    }\n\n    if (symbols[mode][value] && symbols[mode][value].replace) {\n        value = symbols[mode][value].replace;\n    }\n\n    var fontName = fontMap[font].fontName;\n    if (fontMetrics.getCharacterMetrics(value, fontName)) {\n        return fontMap[options.font].variant;\n    }\n\n    return null;\n};\n\n/**\n * Functions for handling the different types of groups found in the parse\n * tree. Each function should take a parse group and return a MathML node.\n */\nvar groupTypes = {};\n\ngroupTypes.mathord = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mi\",\n        [makeText(group.value, group.mode)]);\n\n    var variant = getVariant(group, options);\n    if (variant) {\n        node.setAttribute(\"mathvariant\", variant);\n    }\n    return node;\n};\n\ngroupTypes.textord = function(group, options) {\n    var text = makeText(group.value, group.mode);\n\n    var variant = getVariant(group, options) || \"normal\";\n\n    var node;\n    if (/[0-9]/.test(group.value)) {\n        // TODO(kevinb) merge adjacent <mn> nodes\n        // do it as a post processing step\n        node = new mathMLTree.MathNode(\"mn\", [text]);\n        if (options.font) {\n            node.setAttribute(\"mathvariant\", variant);\n        }\n    } else {\n        node = new mathMLTree.MathNode(\"mi\", [text]);\n        node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n};\n\ngroupTypes.bin = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.rel = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.open = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.close = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.inner = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.punct = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    node.setAttribute(\"separator\", \"true\");\n\n    return node;\n};\n\ngroupTypes.ordgroup = function(group, options) {\n    var inner = buildExpression(group.value, options);\n\n    var node = new mathMLTree.MathNode(\"mrow\", inner);\n\n    return node;\n};\n\ngroupTypes.text = function(group, options) {\n    var inner = buildExpression(group.value.body, options);\n\n    var node = new mathMLTree.MathNode(\"mtext\", inner);\n\n    return node;\n};\n\ngroupTypes.color = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n    node.setAttribute(\"mathcolor\", group.value.color);\n\n    return node;\n};\n\ngroupTypes.supsub = function(group, options) {\n    var children = [buildGroup(group.value.base, options)];\n\n    if (group.value.sub) {\n        children.push(buildGroup(group.value.sub, options));\n    }\n\n    if (group.value.sup) {\n        children.push(buildGroup(group.value.sup, options));\n    }\n\n    var nodeType;\n    if (!group.value.sub) {\n        nodeType = \"msup\";\n    } else if (!group.value.sup) {\n        nodeType = \"msub\";\n    } else {\n        nodeType = \"msubsup\";\n    }\n\n    var node = new mathMLTree.MathNode(nodeType, children);\n\n    return node;\n};\n\ngroupTypes.genfrac = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mfrac\",\n        [buildGroup(group.value.numer, options),\n         buildGroup(group.value.denom, options)]);\n\n    if (!group.value.hasBarLine) {\n        node.setAttribute(\"linethickness\", \"0px\");\n    }\n\n    if (group.value.leftDelim != null || group.value.rightDelim != null) {\n        var withDelims = [];\n\n        if (group.value.leftDelim != null) {\n            var leftOp = new mathMLTree.MathNode(\n                \"mo\", [new mathMLTree.TextNode(group.value.leftDelim)]);\n\n            leftOp.setAttribute(\"fence\", \"true\");\n\n            withDelims.push(leftOp);\n        }\n\n        withDelims.push(node);\n\n        if (group.value.rightDelim != null) {\n            var rightOp = new mathMLTree.MathNode(\n                \"mo\", [new mathMLTree.TextNode(group.value.rightDelim)]);\n\n            rightOp.setAttribute(\"fence\", \"true\");\n\n            withDelims.push(rightOp);\n        }\n\n        var outerNode = new mathMLTree.MathNode(\"mrow\", withDelims);\n\n        return outerNode;\n    }\n\n    return node;\n};\n\ngroupTypes.array = function(group, options) {\n    return new mathMLTree.MathNode(\n        \"mtable\", group.value.body.map(function(row) {\n            return new mathMLTree.MathNode(\n                \"mtr\", row.map(function(cell) {\n                    return new mathMLTree.MathNode(\n                        \"mtd\", [buildGroup(cell, options)]);\n                }));\n        }));\n};\n\ngroupTypes.sqrt = function(group, options) {\n    var node;\n    if (group.value.index) {\n        node = new mathMLTree.MathNode(\n            \"mroot\", [\n                buildGroup(group.value.body, options),\n                buildGroup(group.value.index, options),\n            ]);\n    } else {\n        node = new mathMLTree.MathNode(\n            \"msqrt\", [buildGroup(group.value.body, options)]);\n    }\n\n    return node;\n};\n\ngroupTypes.leftright = function(group, options) {\n    var inner = buildExpression(group.value.body, options);\n\n    if (group.value.left !== \".\") {\n        var leftNode = new mathMLTree.MathNode(\n            \"mo\", [makeText(group.value.left, group.mode)]);\n\n        leftNode.setAttribute(\"fence\", \"true\");\n\n        inner.unshift(leftNode);\n    }\n\n    if (group.value.right !== \".\") {\n        var rightNode = new mathMLTree.MathNode(\n            \"mo\", [makeText(group.value.right, group.mode)]);\n\n        rightNode.setAttribute(\"fence\", \"true\");\n\n        inner.push(rightNode);\n    }\n\n    var outerNode = new mathMLTree.MathNode(\"mrow\", inner);\n\n    return outerNode;\n};\n\ngroupTypes.accent = function(group, options) {\n    var accentNode = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value.accent, group.mode)]);\n\n    var node = new mathMLTree.MathNode(\n        \"mover\",\n        [buildGroup(group.value.base, options),\n         accentNode]);\n\n    node.setAttribute(\"accent\", \"true\");\n\n    return node;\n};\n\ngroupTypes.spacing = function(group) {\n    var node;\n\n    if (group.value === \"\\\\ \" || group.value === \"\\\\space\" ||\n        group.value === \" \" || group.value === \"~\") {\n        node = new mathMLTree.MathNode(\n            \"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n    } else {\n        node = new mathMLTree.MathNode(\"mspace\");\n\n        node.setAttribute(\n            \"width\", buildCommon.spacingFunctions[group.value].size);\n    }\n\n    return node;\n};\n\ngroupTypes.op = function(group) {\n    var node;\n\n    // TODO(emily): handle big operators using the `largeop` attribute\n\n    if (group.value.symbol) {\n        // This is a symbol. Just add the symbol.\n        node = new mathMLTree.MathNode(\n            \"mo\", [makeText(group.value.body, group.mode)]);\n    } else {\n        // This is a text operator. Add all of the characters from the\n        // operator's name.\n        // TODO(emily): Add a space in the middle of some of these\n        // operators, like \\limsup.\n        node = new mathMLTree.MathNode(\n            \"mi\", [new mathMLTree.TextNode(group.value.body.slice(1))]);\n    }\n\n    return node;\n};\n\ngroupTypes.katex = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mtext\", [new mathMLTree.TextNode(\"KaTeX\")]);\n\n    return node;\n};\n\ngroupTypes.font = function(group, options) {\n    var font = group.value.font;\n    return buildGroup(group.value.body, options.withFont(font));\n};\n\ngroupTypes.delimsizing = function(group) {\n    var children = [];\n\n    if (group.value.value !== \".\") {\n        children.push(makeText(group.value.value, group.mode));\n    }\n\n    var node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.value.delimType === \"open\" ||\n        group.value.delimType === \"close\") {\n        // Only some of the delimsizing functions act as fences, and they\n        // return \"open\" or \"close\" delimTypes.\n        node.setAttribute(\"fence\", \"true\");\n    } else {\n        // Explicitly disable fencing if it's not a fence, to override the\n        // defaults.\n        node.setAttribute(\"fence\", \"false\");\n    }\n\n    return node;\n};\n\ngroupTypes.styling = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n    var styleAttributes = {\n        \"display\": [\"0\", \"true\"],\n        \"text\": [\"0\", \"false\"],\n        \"script\": [\"1\", \"false\"],\n        \"scriptscript\": [\"2\", \"false\"],\n    };\n\n    var attr = styleAttributes[group.value.style];\n\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n\n    return node;\n};\n\ngroupTypes.sizing = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n    // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n    node.setAttribute(\n        \"mathsize\", buildCommon.sizingMultiplier[group.value.size] + \"em\");\n\n    return node;\n};\n\ngroupTypes.overline = function(group, options) {\n    var operator = new mathMLTree.MathNode(\n        \"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n\n    var node = new mathMLTree.MathNode(\n        \"mover\",\n        [buildGroup(group.value.body, options),\n         operator]);\n    node.setAttribute(\"accent\", \"true\");\n\n    return node;\n};\n\ngroupTypes.underline = function(group, options) {\n    var operator = new mathMLTree.MathNode(\n        \"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n\n    var node = new mathMLTree.MathNode(\n        \"munder\",\n        [buildGroup(group.value.body, options),\n         operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n\n    return node;\n};\n\ngroupTypes.rule = function(group) {\n    // TODO(emily): Figure out if there's an actual way to draw black boxes\n    // in MathML.\n    var node = new mathMLTree.MathNode(\"mrow\");\n\n    return node;\n};\n\ngroupTypes.llap = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mpadded\", [buildGroup(group.value.body, options)]);\n\n    node.setAttribute(\"lspace\", \"-1width\");\n    node.setAttribute(\"width\", \"0px\");\n\n    return node;\n};\n\ngroupTypes.rlap = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mpadded\", [buildGroup(group.value.body, options)]);\n\n    node.setAttribute(\"width\", \"0px\");\n\n    return node;\n};\n\ngroupTypes.phantom = function(group, options, prev) {\n    var inner = buildExpression(group.value.value, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n};\n\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes. A little simpler than the HTML version because we don't do any\n * previous-node handling.\n */\nvar buildExpression = function(expression, options) {\n    var groups = [];\n    for (var i = 0; i < expression.length; i++) {\n        var group = expression[i];\n        groups.push(buildGroup(group, options));\n    }\n    return groups;\n};\n\n/**\n * Takes a group from the parser and calls the appropriate groupTypes function\n * on it to produce a MathML node.\n */\nvar buildGroup = function(group, options) {\n    if (!group) {\n        return new mathMLTree.MathNode(\"mrow\");\n    }\n\n    if (groupTypes[group.type]) {\n        // Call the groupTypes function\n        return groupTypes[group.type](group, options);\n    } else {\n        throw new ParseError(\n            \"Got group of unknown type: '\" + group.type + \"'\");\n    }\n};\n\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\nvar buildMathML = function(tree, texExpression, options) {\n    var expression = buildExpression(tree, options);\n\n    // Wrap up the expression in an mrow so it is presented in the semantics\n    // tag correctly.\n    var wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n\n    // Build a TeX annotation of the source\n    var annotation = new mathMLTree.MathNode(\n        \"annotation\", [new mathMLTree.TextNode(texExpression)]);\n\n    annotation.setAttribute(\"encoding\", \"application/x-tex\");\n\n    var semantics = new mathMLTree.MathNode(\n        \"semantics\", [wrapper, annotation]);\n\n    var math = new mathMLTree.MathNode(\"math\", [semantics]);\n\n    // You can't style <math> nodes, so we wrap the node in a span.\n    return makeSpan([\"katex-mathml\"], [math]);\n};\n\nmodule.exports = buildMathML;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}