{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\nvar ParseError = require(\"./ParseError\");\nvar Style = require(\"./Style\");\nvar buildCommon = require(\"./buildCommon\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\nvar makeSpan = buildCommon.makeSpan;\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar getMetrics = function (symbol, font) {\n  if (symbols.math[symbol] && symbols.math[symbol].replace) {\n    return fontMetrics.getCharacterMetrics(symbols.math[symbol].replace, font);\n  } else {\n    return fontMetrics.getCharacterMetrics(symbol, font);\n  }\n};\n\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\nvar mathrmSize = function (value, size, mode) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode);\n};\n\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\nvar styleWrap = function (delim, toStyle, options) {\n  var span = makeSpan([\"style-wrap\", options.style.reset(), toStyle.cls()], [delim]);\n  var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;\n  span.height *= multiplier;\n  span.depth *= multiplier;\n  span.maxFontSize = toStyle.sizeMultiplier;\n  return span;\n};\n\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\nvar makeSmallDelim = function (delim, style, center, options, mode) {\n  var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode);\n  var span = styleWrap(text, style, options);\n  if (center) {\n    var shift = (1 - options.style.sizeMultiplier / style.sizeMultiplier) * fontMetrics.metrics.axisHeight;\n    span.style.top = shift + \"em\";\n    span.height -= shift;\n    span.depth += shift;\n  }\n  return span;\n};\n\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\nvar makeLargeDelim = function (delim, size, center, options, mode) {\n  var inner = mathrmSize(delim, size, mode);\n  var span = styleWrap(makeSpan([\"delimsizing\", \"size\" + size], [inner], options.getColor()), Style.TEXT, options);\n  if (center) {\n    var shift = (1 - options.style.sizeMultiplier) * fontMetrics.metrics.axisHeight;\n    span.style.top = shift + \"em\";\n    span.height -= shift;\n    span.depth += shift;\n  }\n  return span;\n};\n\n/**\n * Make an inner span with the given offset and in the given font. This is used\n * in `makeStackedDelim` to make the stacking pieces for the delimiter.\n */\nvar makeInner = function (symbol, font, mode) {\n  var sizeClass;\n  // Apply the correct CSS class to choose the right font.\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else if (font === \"Size4-Regular\") {\n    sizeClass = \"delim-size4\";\n  }\n  var inner = makeSpan([\"delimsizinginner\", sizeClass], [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);\n\n  // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n  return {\n    type: \"elem\",\n    elem: inner\n  };\n};\n\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\nvar makeStackedDelim = function (delim, heightTotal, center, options, mode) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  var top;\n  var middle;\n  var repeat;\n  var bottom;\n  top = repeat = bottom = delim;\n  middle = null;\n  // Also keep track of what font the delimiters are in\n  var font = \"Size1-Regular\";\n\n  // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23d0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23d0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23d0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23a1\";\n    repeat = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23a4\";\n    repeat = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lfloor\") {\n    repeat = top = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lceil\") {\n    top = \"\\u23a1\";\n    repeat = bottom = \"\\u23a2\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rfloor\") {\n    repeat = top = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rceil\") {\n    top = \"\\u23a4\";\n    repeat = bottom = \"\\u23a5\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"(\") {\n    top = \"\\u239b\";\n    repeat = \"\\u239c\";\n    bottom = \"\\u239d\";\n    font = \"Size4-Regular\";\n  } else if (delim === \")\") {\n    top = \"\\u239e\";\n    repeat = \"\\u239f\";\n    bottom = \"\\u23a0\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23a7\";\n    middle = \"\\u23a8\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23ab\";\n    middle = \"\\u23ac\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\surd\") {\n    top = \"\\ue001\";\n    bottom = \"\\u23b7\";\n    repeat = \"\\ue000\";\n    font = \"Size4-Regular\";\n  }\n\n  // Get the metrics of the four sections\n  var topMetrics = getMetrics(top, font);\n  var topHeightTotal = topMetrics.height + topMetrics.depth;\n  var repeatMetrics = getMetrics(repeat, font);\n  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  var bottomMetrics = getMetrics(bottom, font);\n  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  var middleHeightTotal = 0;\n  var middleFactor = 1;\n  if (middle !== null) {\n    var middleMetrics = getMetrics(middle, font);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  }\n\n  // Calcuate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;\n\n  // Compute the number of copies of the repeat symbol we will need\n  var repeatCount = Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal));\n\n  // Compute the total height of the delimiter including all the symbols\n  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;\n\n  // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n  var axisHeight = fontMetrics.metrics.axisHeight;\n  if (center) {\n    axisHeight *= options.style.sizeMultiplier;\n  }\n  // Calculate the depth\n  var depth = realHeightTotal / 2 - axisHeight;\n\n  // Now, we start building the pieces that will go into the vlist\n\n  // Keep a list of the inner pieces\n  var inners = [];\n\n  // Add the bottom symbol\n  inners.push(makeInner(bottom, font, mode));\n  var i;\n  if (middle === null) {\n    // Add that many symbols\n    for (i = 0; i < repeatCount; i++) {\n      inners.push(makeInner(repeat, font, mode));\n    }\n  } else {\n    // When there is a middle bit, we need the middle part and two repeated\n    // sections\n    for (i = 0; i < repeatCount; i++) {\n      inners.push(makeInner(repeat, font, mode));\n    }\n    inners.push(makeInner(middle, font, mode));\n    for (i = 0; i < repeatCount; i++) {\n      inners.push(makeInner(repeat, font, mode));\n    }\n  }\n\n  // Add the top symbol\n  inners.push(makeInner(top, font, mode));\n\n  // Finally, build the vlist\n  var inner = buildCommon.makeVList(inners, \"bottom\", depth, options);\n  return styleWrap(makeSpan([\"delimsizing\", \"mult\"], [inner], options.getColor()), Style.TEXT, options);\n};\n\n// There are three kinds of delimiters, delimiters that stack when they become\n// too large\nvar stackLargeDelimiters = [\"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\", \"\\\\surd\"];\n\n// delimiters that always stack\nvar stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\"];\n\n// and delimiters that never stack\nvar stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"];\n\n// Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\nvar makeSizedDelim = function (delim, size, options, mode) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\") {\n    delim = \"\\\\rangle\";\n  }\n\n  // Sized delimiters are never centered.\n  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {\n    return makeLargeDelim(delim, size, false, options, mode);\n  } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode);\n  } else {\n    throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style.SCRIPT\n}, {\n  type: \"small\",\n  style: Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}];\n\n// Delimiters that always stack try the small delimiters first, then stack\nvar stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style.SCRIPT\n}, {\n  type: \"small\",\n  style: Style.TEXT\n}, {\n  type: \"stack\"\n}];\n\n// Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\nvar stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style.SCRIPT\n}, {\n  type: \"small\",\n  style: Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n */\nvar delimTypeToFont = function (type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  }\n};\n\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\nvar traverseSequence = function (delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  var start = Math.min(2, 3 - options.style.size);\n  for (var i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));\n    var heightDepth = metrics.height + metrics.depth;\n\n    // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      heightDepth *= sequence[i].style.sizeMultiplier;\n    }\n\n    // Check if the delimiter at this size works for the given height.\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  }\n\n  // If we reached the end of the sequence, return the last sequence element.\n  return sequence[sequence.length - 1];\n};\n\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\nvar makeCustomSizedDelim = function (delim, height, center, options, mode) {\n  if (delim === \"<\" || delim === \"\\\\lt\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\") {\n    delim = \"\\\\rangle\";\n  }\n\n  // Decide what sequence to use\n  var sequence;\n  if (utils.contains(stackNeverDelimiters, delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (utils.contains(stackLargeDelimiters, delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  }\n\n  // Look through the sequence\n  var delimType = traverseSequence(delim, height, sequence, options);\n\n  // Depending on the sequence element we decided on, call the appropriate\n  // function.\n  if (delimType.type === \"small\") {\n    return makeSmallDelim(delim, delimType.style, center, options, mode);\n  } else if (delimType.type === \"large\") {\n    return makeLargeDelim(delim, delimType.size, center, options, mode);\n  } else if (delimType.type === \"stack\") {\n    return makeStackedDelim(delim, height, center, options, mode);\n  }\n};\n\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\nvar makeLeftRightDelim = function (delim, height, depth, options, mode) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  var axisHeight = fontMetrics.metrics.axisHeight * options.style.sizeMultiplier;\n\n  // Taken from TeX source, tex.web, function make_left_right\n  var delimiterFactor = 901;\n  var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;\n  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  var totalHeight = Math.max(\n  // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);\n\n  // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n  return makeCustomSizedDelim(delim, totalHeight, true, options, mode);\n};\nmodule.exports = {\n  sizedDelim: makeSizedDelim,\n  customSizedDelim: makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n};","map":{"version":3,"names":["ParseError","require","Style","buildCommon","fontMetrics","symbols","utils","makeSpan","getMetrics","symbol","font","math","replace","getCharacterMetrics","mathrmSize","value","size","mode","makeSymbol","styleWrap","delim","toStyle","options","span","style","reset","cls","multiplier","sizeMultiplier","height","depth","maxFontSize","makeSmallDelim","center","text","shift","metrics","axisHeight","top","makeLargeDelim","inner","getColor","TEXT","makeInner","sizeClass","type","elem","makeStackedDelim","heightTotal","middle","repeat","bottom","topMetrics","topHeightTotal","repeatMetrics","repeatHeightTotal","bottomMetrics","bottomHeightTotal","middleHeightTotal","middleFactor","middleMetrics","minHeight","repeatCount","Math","ceil","realHeightTotal","inners","push","i","makeVList","stackLargeDelimiters","stackAlwaysDelimiters","stackNeverDelimiters","sizeToMaxHeight","makeSizedDelim","contains","stackNeverDelimiterSequence","SCRIPTSCRIPT","SCRIPT","stackAlwaysDelimiterSequence","stackLargeDelimiterSequence","delimTypeToFont","traverseSequence","sequence","start","min","length","heightDepth","makeCustomSizedDelim","delimType","makeLeftRightDelim","delimiterFactor","delimiterExtend","ptPerEm","maxDistFromAxis","max","totalHeight","module","exports","sizedDelim","customSizedDelim","leftRightDelim"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/katex/src/delimiter.js"],"sourcesContent":["/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\nvar ParseError = require(\"./ParseError\");\nvar Style = require(\"./Style\");\n\nvar buildCommon = require(\"./buildCommon\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\n\nvar makeSpan = buildCommon.makeSpan;\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar getMetrics = function(symbol, font) {\n    if (symbols.math[symbol] && symbols.math[symbol].replace) {\n        return fontMetrics.getCharacterMetrics(\n            symbols.math[symbol].replace, font);\n    } else {\n        return fontMetrics.getCharacterMetrics(\n            symbol, font);\n    }\n};\n\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\nvar mathrmSize = function(value, size, mode) {\n    return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode);\n};\n\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\nvar styleWrap = function(delim, toStyle, options) {\n    var span = makeSpan(\n        [\"style-wrap\", options.style.reset(), toStyle.cls()], [delim]);\n\n    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;\n\n    span.height *= multiplier;\n    span.depth *= multiplier;\n    span.maxFontSize = toStyle.sizeMultiplier;\n\n    return span;\n};\n\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\nvar makeSmallDelim = function(delim, style, center, options, mode) {\n    var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode);\n\n    var span = styleWrap(text, style, options);\n\n    if (center) {\n        var shift =\n            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *\n            fontMetrics.metrics.axisHeight;\n\n        span.style.top = shift + \"em\";\n        span.height -= shift;\n        span.depth += shift;\n    }\n\n    return span;\n};\n\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\nvar makeLargeDelim = function(delim, size, center, options, mode) {\n    var inner = mathrmSize(delim, size, mode);\n\n    var span = styleWrap(\n        makeSpan([\"delimsizing\", \"size\" + size],\n                 [inner], options.getColor()),\n        Style.TEXT, options);\n\n    if (center) {\n        var shift = (1 - options.style.sizeMultiplier) *\n            fontMetrics.metrics.axisHeight;\n\n        span.style.top = shift + \"em\";\n        span.height -= shift;\n        span.depth += shift;\n    }\n\n    return span;\n};\n\n/**\n * Make an inner span with the given offset and in the given font. This is used\n * in `makeStackedDelim` to make the stacking pieces for the delimiter.\n */\nvar makeInner = function(symbol, font, mode) {\n    var sizeClass;\n    // Apply the correct CSS class to choose the right font.\n    if (font === \"Size1-Regular\") {\n        sizeClass = \"delim-size1\";\n    } else if (font === \"Size4-Regular\") {\n        sizeClass = \"delim-size4\";\n    }\n\n    var inner = makeSpan(\n        [\"delimsizinginner\", sizeClass],\n        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);\n\n    // Since this will be passed into `makeVList` in the end, wrap the element\n    // in the appropriate tag that VList uses.\n    return {type: \"elem\", elem: inner};\n};\n\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\nvar makeStackedDelim = function(delim, heightTotal, center, options, mode) {\n    // There are four parts, the top, an optional middle, a repeated part, and a\n    // bottom.\n    var top;\n    var middle;\n    var repeat;\n    var bottom;\n    top = repeat = bottom = delim;\n    middle = null;\n    // Also keep track of what font the delimiters are in\n    var font = \"Size1-Regular\";\n\n    // We set the parts and font based on the symbol. Note that we use\n    // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n    // repeats of the arrows\n    if (delim === \"\\\\uparrow\") {\n        repeat = bottom = \"\\u23d0\";\n    } else if (delim === \"\\\\Uparrow\") {\n        repeat = bottom = \"\\u2016\";\n    } else if (delim === \"\\\\downarrow\") {\n        top = repeat = \"\\u23d0\";\n    } else if (delim === \"\\\\Downarrow\") {\n        top = repeat = \"\\u2016\";\n    } else if (delim === \"\\\\updownarrow\") {\n        top = \"\\\\uparrow\";\n        repeat = \"\\u23d0\";\n        bottom = \"\\\\downarrow\";\n    } else if (delim === \"\\\\Updownarrow\") {\n        top = \"\\\\Uparrow\";\n        repeat = \"\\u2016\";\n        bottom = \"\\\\Downarrow\";\n    } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n        top = \"\\u23a1\";\n        repeat = \"\\u23a2\";\n        bottom = \"\\u23a3\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n        top = \"\\u23a4\";\n        repeat = \"\\u23a5\";\n        bottom = \"\\u23a6\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lfloor\") {\n        repeat = top = \"\\u23a2\";\n        bottom = \"\\u23a3\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lceil\") {\n        top = \"\\u23a1\";\n        repeat = bottom = \"\\u23a2\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rfloor\") {\n        repeat = top = \"\\u23a5\";\n        bottom = \"\\u23a6\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rceil\") {\n        top = \"\\u23a4\";\n        repeat = bottom = \"\\u23a5\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"(\") {\n        top = \"\\u239b\";\n        repeat = \"\\u239c\";\n        bottom = \"\\u239d\";\n        font = \"Size4-Regular\";\n    } else if (delim === \")\") {\n        top = \"\\u239e\";\n        repeat = \"\\u239f\";\n        bottom = \"\\u23a0\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n        top = \"\\u23a7\";\n        middle = \"\\u23a8\";\n        bottom = \"\\u23a9\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n        top = \"\\u23ab\";\n        middle = \"\\u23ac\";\n        bottom = \"\\u23ad\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lgroup\") {\n        top = \"\\u23a7\";\n        bottom = \"\\u23a9\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rgroup\") {\n        top = \"\\u23ab\";\n        bottom = \"\\u23ad\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lmoustache\") {\n        top = \"\\u23a7\";\n        bottom = \"\\u23ad\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rmoustache\") {\n        top = \"\\u23ab\";\n        bottom = \"\\u23a9\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\surd\") {\n        top = \"\\ue001\";\n        bottom = \"\\u23b7\";\n        repeat = \"\\ue000\";\n        font = \"Size4-Regular\";\n    }\n\n    // Get the metrics of the four sections\n    var topMetrics = getMetrics(top, font);\n    var topHeightTotal = topMetrics.height + topMetrics.depth;\n    var repeatMetrics = getMetrics(repeat, font);\n    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n    var bottomMetrics = getMetrics(bottom, font);\n    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n    var middleHeightTotal = 0;\n    var middleFactor = 1;\n    if (middle !== null) {\n        var middleMetrics = getMetrics(middle, font);\n        middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n        middleFactor = 2; // repeat symmetrically above and below middle\n    }\n\n    // Calcuate the minimal height that the delimiter can have.\n    // It is at least the size of the top, bottom, and optional middle combined.\n    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;\n\n    // Compute the number of copies of the repeat symbol we will need\n    var repeatCount = Math.ceil(\n        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));\n\n    // Compute the total height of the delimiter including all the symbols\n    var realHeightTotal =\n        minHeight + repeatCount * middleFactor * repeatHeightTotal;\n\n    // The center of the delimiter is placed at the center of the axis. Note\n    // that in this context, \"center\" means that the delimiter should be\n    // centered around the axis in the current style, while normally it is\n    // centered around the axis in textstyle.\n    var axisHeight = fontMetrics.metrics.axisHeight;\n    if (center) {\n        axisHeight *= options.style.sizeMultiplier;\n    }\n    // Calculate the depth\n    var depth = realHeightTotal / 2 - axisHeight;\n\n    // Now, we start building the pieces that will go into the vlist\n\n    // Keep a list of the inner pieces\n    var inners = [];\n\n    // Add the bottom symbol\n    inners.push(makeInner(bottom, font, mode));\n\n    var i;\n    if (middle === null) {\n        // Add that many symbols\n        for (i = 0; i < repeatCount; i++) {\n            inners.push(makeInner(repeat, font, mode));\n        }\n    } else {\n        // When there is a middle bit, we need the middle part and two repeated\n        // sections\n        for (i = 0; i < repeatCount; i++) {\n            inners.push(makeInner(repeat, font, mode));\n        }\n        inners.push(makeInner(middle, font, mode));\n        for (i = 0; i < repeatCount; i++) {\n            inners.push(makeInner(repeat, font, mode));\n        }\n    }\n\n    // Add the top symbol\n    inners.push(makeInner(top, font, mode));\n\n    // Finally, build the vlist\n    var inner = buildCommon.makeVList(inners, \"bottom\", depth, options);\n\n    return styleWrap(\n        makeSpan([\"delimsizing\", \"mult\"], [inner], options.getColor()),\n        Style.TEXT, options);\n};\n\n// There are three kinds of delimiters, delimiters that stack when they become\n// too large\nvar stackLargeDelimiters = [\n    \"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\",\n    \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\",\n    \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\",\n    \"\\\\surd\",\n];\n\n// delimiters that always stack\nvar stackAlwaysDelimiters = [\n    \"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\",\n    \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\",\n    \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\",\n    \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\",\n    \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\",\n];\n\n// and delimiters that never stack\nvar stackNeverDelimiters = [\n    \"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\",\n];\n\n// Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\nvar makeSizedDelim = function(delim, size, options, mode) {\n    // < and > turn into \\langle and \\rangle in delimiters\n    if (delim === \"<\" || delim === \"\\\\lt\") {\n        delim = \"\\\\langle\";\n    } else if (delim === \">\" || delim === \"\\\\gt\") {\n        delim = \"\\\\rangle\";\n    }\n\n    // Sized delimiters are never centered.\n    if (utils.contains(stackLargeDelimiters, delim) ||\n        utils.contains(stackNeverDelimiters, delim)) {\n        return makeLargeDelim(delim, size, false, options, mode);\n    } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n        return makeStackedDelim(\n            delim, sizeToMaxHeight[size], false, options, mode);\n    } else {\n        throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n    }\n};\n\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [\n    {type: \"small\", style: Style.SCRIPTSCRIPT},\n    {type: \"small\", style: Style.SCRIPT},\n    {type: \"small\", style: Style.TEXT},\n    {type: \"large\", size: 1},\n    {type: \"large\", size: 2},\n    {type: \"large\", size: 3},\n    {type: \"large\", size: 4},\n];\n\n// Delimiters that always stack try the small delimiters first, then stack\nvar stackAlwaysDelimiterSequence = [\n    {type: \"small\", style: Style.SCRIPTSCRIPT},\n    {type: \"small\", style: Style.SCRIPT},\n    {type: \"small\", style: Style.TEXT},\n    {type: \"stack\"},\n];\n\n// Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\nvar stackLargeDelimiterSequence = [\n    {type: \"small\", style: Style.SCRIPTSCRIPT},\n    {type: \"small\", style: Style.SCRIPT},\n    {type: \"small\", style: Style.TEXT},\n    {type: \"large\", size: 1},\n    {type: \"large\", size: 2},\n    {type: \"large\", size: 3},\n    {type: \"large\", size: 4},\n    {type: \"stack\"},\n];\n\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n */\nvar delimTypeToFont = function(type) {\n    if (type.type === \"small\") {\n        return \"Main-Regular\";\n    } else if (type.type === \"large\") {\n        return \"Size\" + type.size + \"-Regular\";\n    } else if (type.type === \"stack\") {\n        return \"Size4-Regular\";\n    }\n};\n\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\nvar traverseSequence = function(delim, height, sequence, options) {\n    // Here, we choose the index we should start at in the sequences. In smaller\n    // sizes (which correspond to larger numbers in style.size) we start earlier\n    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n    var start = Math.min(2, 3 - options.style.size);\n    for (var i = start; i < sequence.length; i++) {\n        if (sequence[i].type === \"stack\") {\n            // This is always the last delimiter, so we just break the loop now.\n            break;\n        }\n\n        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));\n        var heightDepth = metrics.height + metrics.depth;\n\n        // Small delimiters are scaled down versions of the same font, so we\n        // account for the style change size.\n\n        if (sequence[i].type === \"small\") {\n            heightDepth *= sequence[i].style.sizeMultiplier;\n        }\n\n        // Check if the delimiter at this size works for the given height.\n        if (heightDepth > height) {\n            return sequence[i];\n        }\n    }\n\n    // If we reached the end of the sequence, return the last sequence element.\n    return sequence[sequence.length - 1];\n};\n\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\nvar makeCustomSizedDelim = function(delim, height, center, options, mode) {\n    if (delim === \"<\" || delim === \"\\\\lt\") {\n        delim = \"\\\\langle\";\n    } else if (delim === \">\" || delim === \"\\\\gt\") {\n        delim = \"\\\\rangle\";\n    }\n\n    // Decide what sequence to use\n    var sequence;\n    if (utils.contains(stackNeverDelimiters, delim)) {\n        sequence = stackNeverDelimiterSequence;\n    } else if (utils.contains(stackLargeDelimiters, delim)) {\n        sequence = stackLargeDelimiterSequence;\n    } else {\n        sequence = stackAlwaysDelimiterSequence;\n    }\n\n    // Look through the sequence\n    var delimType = traverseSequence(delim, height, sequence, options);\n\n    // Depending on the sequence element we decided on, call the appropriate\n    // function.\n    if (delimType.type === \"small\") {\n        return makeSmallDelim(delim, delimType.style, center, options, mode);\n    } else if (delimType.type === \"large\") {\n        return makeLargeDelim(delim, delimType.size, center, options, mode);\n    } else if (delimType.type === \"stack\") {\n        return makeStackedDelim(delim, height, center, options, mode);\n    }\n};\n\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\nvar makeLeftRightDelim = function(delim, height, depth, options, mode) {\n    // We always center \\left/\\right delimiters, so the axis is always shifted\n    var axisHeight =\n        fontMetrics.metrics.axisHeight * options.style.sizeMultiplier;\n\n    // Taken from TeX source, tex.web, function make_left_right\n    var delimiterFactor = 901;\n    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;\n\n    var maxDistFromAxis = Math.max(\n        height - axisHeight, depth + axisHeight);\n\n    var totalHeight = Math.max(\n        // In real TeX, calculations are done using integral values which are\n        // 65536 per pt, or 655360 per em. So, the division here truncates in\n        // TeX but doesn't here, producing different results. If we wanted to\n        // exactly match TeX's calculation, we could do\n        //   Math.floor(655360 * maxDistFromAxis / 500) *\n        //    delimiterFactor / 655360\n        // (To see the difference, compare\n        //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n        // in TeX and KaTeX)\n        maxDistFromAxis / 500 * delimiterFactor,\n        2 * maxDistFromAxis - delimiterExtend);\n\n    // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n    // height\n    return makeCustomSizedDelim(delim, totalHeight, true, options, mode);\n};\n\nmodule.exports = {\n    sizedDelim: makeSizedDelim,\n    customSizedDelim: makeCustomSizedDelim,\n    leftRightDelim: makeLeftRightDelim,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}