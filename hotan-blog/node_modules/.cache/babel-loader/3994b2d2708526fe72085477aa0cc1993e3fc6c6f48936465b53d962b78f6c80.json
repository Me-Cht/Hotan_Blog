{"ast":null,"code":"/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n */\n\nvar utils = require(\"./utils\");\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove null or empty classes.\n */\nvar createClass = function (classes) {\n  classes = classes.slice();\n  for (var i = classes.length - 1; i >= 0; i--) {\n    if (!classes[i]) {\n      classes.splice(i, 1);\n    }\n  }\n  return classes.join(\" \");\n};\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n */\nfunction span(classes, children, height, depth, maxFontSize, style) {\n  this.classes = classes || [];\n  this.children = children || [];\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.maxFontSize = maxFontSize || 0;\n  this.style = style || {};\n  this.attributes = {};\n}\n\n/**\n * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all\n * browsers support attributes the same, and having too many custom attributes\n * is probably bad.\n */\nspan.prototype.setAttribute = function (attribute, value) {\n  this.attributes[attribute] = value;\n};\n\n/**\n * Convert the span into an HTML node\n */\nspan.prototype.toNode = function () {\n  var span = document.createElement(\"span\");\n\n  // Apply the class\n  span.className = createClass(this.classes);\n\n  // Apply inline styles\n  for (var style in this.style) {\n    if (Object.prototype.hasOwnProperty.call(this.style, style)) {\n      span.style[style] = this.style[style];\n    }\n  }\n\n  // Apply attributes\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      span.setAttribute(attr, this.attributes[attr]);\n    }\n  }\n\n  // Append the children, also as HTML nodes\n  for (var i = 0; i < this.children.length; i++) {\n    span.appendChild(this.children[i].toNode());\n  }\n  return span;\n};\n\n/**\n * Convert the span into an HTML markup string\n */\nspan.prototype.toMarkup = function () {\n  var markup = \"<span\";\n\n  // Add the class\n  if (this.classes.length) {\n    markup += \" class=\\\"\";\n    markup += utils.escape(createClass(this.classes));\n    markup += \"\\\"\";\n  }\n  var styles = \"\";\n\n  // Add the styles, after hyphenation\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  }\n\n  // Add the attributes\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      markup += \" \" + attr + \"=\\\"\";\n      markup += utils.escape(this.attributes[attr]);\n      markup += \"\\\"\";\n    }\n  }\n  markup += \">\";\n\n  // Add the markup of the children, also as markup\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n  markup += \"</span>\";\n  return markup;\n};\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. Thus, it only\n * contains children and doesn't have any HTML properties. It also keeps track\n * of a height, depth, and maxFontSize.\n */\nfunction documentFragment(children, height, depth, maxFontSize) {\n  this.children = children || [];\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.maxFontSize = maxFontSize || 0;\n}\n\n/**\n * Convert the fragment into a node\n */\ndocumentFragment.prototype.toNode = function () {\n  // Create a fragment\n  var frag = document.createDocumentFragment();\n\n  // Append the children\n  for (var i = 0; i < this.children.length; i++) {\n    frag.appendChild(this.children[i].toNode());\n  }\n  return frag;\n};\n\n/**\n * Convert the fragment into HTML markup\n */\ndocumentFragment.prototype.toMarkup = function () {\n  var markup = \"\";\n\n  // Simply concatenate the markup for the children together\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n  return markup;\n};\n\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\nfunction symbolNode(value, height, depth, italic, skew, classes, style) {\n  this.value = value || \"\";\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.italic = italic || 0;\n  this.skew = skew || 0;\n  this.classes = classes || [];\n  this.style = style || {};\n  this.maxFontSize = 0;\n}\n\n/**\n * Creates a text node or span from a symbol node. Note that a span is only\n * created if it is needed.\n */\nsymbolNode.prototype.toNode = function () {\n  var node = document.createTextNode(this.value);\n  var span = null;\n  if (this.italic > 0) {\n    span = document.createElement(\"span\");\n    span.style.marginRight = this.italic + \"em\";\n  }\n  if (this.classes.length > 0) {\n    span = span || document.createElement(\"span\");\n    span.className = createClass(this.classes);\n  }\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      span = span || document.createElement(\"span\");\n      span.style[style] = this.style[style];\n    }\n  }\n  if (span) {\n    span.appendChild(node);\n    return span;\n  } else {\n    return node;\n  }\n};\n\n/**\n * Creates markup for a symbol node.\n */\nsymbolNode.prototype.toMarkup = function () {\n  // TODO(alpert): More duplication than I'd like from\n  // span.prototype.toMarkup and symbolNode.prototype.toNode...\n  var needsSpan = false;\n  var markup = \"<span\";\n  if (this.classes.length) {\n    needsSpan = true;\n    markup += \" class=\\\"\";\n    markup += utils.escape(createClass(this.classes));\n    markup += \"\\\"\";\n  }\n  var styles = \"\";\n  if (this.italic > 0) {\n    styles += \"margin-right:\" + this.italic + \"em;\";\n  }\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n  if (styles) {\n    needsSpan = true;\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  }\n  var escaped = utils.escape(this.value);\n  if (needsSpan) {\n    markup += \">\";\n    markup += escaped;\n    markup += \"</span>\";\n    return markup;\n  } else {\n    return escaped;\n  }\n};\nmodule.exports = {\n  span: span,\n  documentFragment: documentFragment,\n  symbolNode: symbolNode\n};","map":{"version":3,"names":["utils","require","createClass","classes","slice","i","length","splice","join","span","children","height","depth","maxFontSize","style","attributes","prototype","setAttribute","attribute","value","toNode","document","createElement","className","Object","hasOwnProperty","call","attr","appendChild","toMarkup","markup","escape","styles","hyphenate","documentFragment","frag","createDocumentFragment","symbolNode","italic","skew","node","createTextNode","marginRight","needsSpan","escaped","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/katex/src/domTree.js"],"sourcesContent":["/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n */\n\nvar utils = require(\"./utils\");\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove null or empty classes.\n */\nvar createClass = function(classes) {\n    classes = classes.slice();\n    for (var i = classes.length - 1; i >= 0; i--) {\n        if (!classes[i]) {\n            classes.splice(i, 1);\n        }\n    }\n\n    return classes.join(\" \");\n};\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n */\nfunction span(classes, children, height, depth, maxFontSize, style) {\n    this.classes = classes || [];\n    this.children = children || [];\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.maxFontSize = maxFontSize || 0;\n    this.style = style || {};\n    this.attributes = {};\n}\n\n/**\n * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all\n * browsers support attributes the same, and having too many custom attributes\n * is probably bad.\n */\nspan.prototype.setAttribute = function(attribute, value) {\n    this.attributes[attribute] = value;\n};\n\n/**\n * Convert the span into an HTML node\n */\nspan.prototype.toNode = function() {\n    var span = document.createElement(\"span\");\n\n    // Apply the class\n    span.className = createClass(this.classes);\n\n    // Apply inline styles\n    for (var style in this.style) {\n        if (Object.prototype.hasOwnProperty.call(this.style, style)) {\n            span.style[style] = this.style[style];\n        }\n    }\n\n    // Apply attributes\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            span.setAttribute(attr, this.attributes[attr]);\n        }\n    }\n\n    // Append the children, also as HTML nodes\n    for (var i = 0; i < this.children.length; i++) {\n        span.appendChild(this.children[i].toNode());\n    }\n\n    return span;\n};\n\n/**\n * Convert the span into an HTML markup string\n */\nspan.prototype.toMarkup = function() {\n    var markup = \"<span\";\n\n    // Add the class\n    if (this.classes.length) {\n        markup += \" class=\\\"\";\n        markup += utils.escape(createClass(this.classes));\n        markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    // Add the styles, after hyphenation\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n        }\n    }\n\n    if (styles) {\n        markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    // Add the attributes\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            markup += \" \" + attr + \"=\\\"\";\n            markup += utils.escape(this.attributes[attr]);\n            markup += \"\\\"\";\n        }\n    }\n\n    markup += \">\";\n\n    // Add the markup of the children, also as markup\n    for (var i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</span>\";\n\n    return markup;\n};\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. Thus, it only\n * contains children and doesn't have any HTML properties. It also keeps track\n * of a height, depth, and maxFontSize.\n */\nfunction documentFragment(children, height, depth, maxFontSize) {\n    this.children = children || [];\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.maxFontSize = maxFontSize || 0;\n}\n\n/**\n * Convert the fragment into a node\n */\ndocumentFragment.prototype.toNode = function() {\n    // Create a fragment\n    var frag = document.createDocumentFragment();\n\n    // Append the children\n    for (var i = 0; i < this.children.length; i++) {\n        frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n};\n\n/**\n * Convert the fragment into HTML markup\n */\ndocumentFragment.prototype.toMarkup = function() {\n    var markup = \"\";\n\n    // Simply concatenate the markup for the children together\n    for (var i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n};\n\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\nfunction symbolNode(value, height, depth, italic, skew, classes, style) {\n    this.value = value || \"\";\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0;\n}\n\n/**\n * Creates a text node or span from a symbol node. Note that a span is only\n * created if it is needed.\n */\nsymbolNode.prototype.toNode = function() {\n    var node = document.createTextNode(this.value);\n    var span = null;\n\n    if (this.italic > 0) {\n        span = document.createElement(\"span\");\n        span.style.marginRight = this.italic + \"em\";\n    }\n\n    if (this.classes.length > 0) {\n        span = span || document.createElement(\"span\");\n        span.className = createClass(this.classes);\n    }\n\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            span = span || document.createElement(\"span\");\n            span.style[style] = this.style[style];\n        }\n    }\n\n    if (span) {\n        span.appendChild(node);\n        return span;\n    } else {\n        return node;\n    }\n};\n\n/**\n * Creates markup for a symbol node.\n */\nsymbolNode.prototype.toMarkup = function() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    var needsSpan = false;\n\n    var markup = \"<span\";\n\n    if (this.classes.length) {\n        needsSpan = true;\n        markup += \" class=\\\"\";\n        markup += utils.escape(createClass(this.classes));\n        markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    if (this.italic > 0) {\n        styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n        }\n    }\n\n    if (styles) {\n        needsSpan = true;\n        markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    var escaped = utils.escape(this.value);\n    if (needsSpan) {\n        markup += \">\";\n        markup += escaped;\n        markup += \"</span>\";\n        return markup;\n    } else {\n        return escaped;\n    }\n};\n\nmodule.exports = {\n    span: span,\n    documentFragment: documentFragment,\n    symbolNode: symbolNode,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}