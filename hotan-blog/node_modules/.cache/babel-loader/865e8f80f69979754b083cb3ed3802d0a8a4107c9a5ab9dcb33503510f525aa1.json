{"ast":null,"code":"function getRelocatable(re) {\n  // In the future, this could use a WeakMap instead of an expando.\n  if (!re.__matchAtRelocatable) {\n    // Disjunctions are the lowest-precedence operator, so we can make any\n    // pattern match the empty string by appending `|()` to it:\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns\n    var source = re.source + '|()';\n\n    // We always make the new regex global.\n    var flags = 'g' + (re.ignoreCase ? 'i' : '') + (re.multiline ? 'm' : '') + (re.unicode ? 'u' : '')\n    // sticky (/.../y) doesn't make sense in conjunction with our relocation\n    // logic, so we ignore it here.\n    ;\n\n    re.__matchAtRelocatable = new RegExp(source, flags);\n  }\n  return re.__matchAtRelocatable;\n}\nfunction matchAt(re, str, pos) {\n  if (re.global || re.sticky) {\n    throw new Error('matchAt(...): Only non-global regexes are supported');\n  }\n  var reloc = getRelocatable(re);\n  reloc.lastIndex = pos;\n  var match = reloc.exec(str);\n  // Last capturing group is our sentinel that indicates whether the regex\n  // matched at the given location.\n  if (match[match.length - 1] == null) {\n    // Original regex matched.\n    match.length = match.length - 1;\n    return match;\n  } else {\n    return null;\n  }\n}\nmodule.exports = matchAt;","map":{"version":3,"names":["getRelocatable","re","__matchAtRelocatable","source","flags","ignoreCase","multiline","unicode","RegExp","matchAt","str","pos","global","sticky","Error","reloc","lastIndex","match","exec","length","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/match-at/lib/matchAt.js"],"sourcesContent":["function getRelocatable(re) {\n  // In the future, this could use a WeakMap instead of an expando.\n  if (!re.__matchAtRelocatable) {\n    // Disjunctions are the lowest-precedence operator, so we can make any\n    // pattern match the empty string by appending `|()` to it:\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns\n    var source = re.source + '|()';\n\n    // We always make the new regex global.\n    var flags = 'g' + (re.ignoreCase ? 'i' : '') + (re.multiline ? 'm' : '') + (re.unicode ? 'u' : '')\n    // sticky (/.../y) doesn't make sense in conjunction with our relocation\n    // logic, so we ignore it here.\n    ;\n\n    re.__matchAtRelocatable = new RegExp(source, flags);\n  }\n  return re.__matchAtRelocatable;\n}\n\nfunction matchAt(re, str, pos) {\n  if (re.global || re.sticky) {\n    throw new Error('matchAt(...): Only non-global regexes are supported');\n  }\n  var reloc = getRelocatable(re);\n  reloc.lastIndex = pos;\n  var match = reloc.exec(str);\n  // Last capturing group is our sentinel that indicates whether the regex\n  // matched at the given location.\n  if (match[match.length - 1] == null) {\n    // Original regex matched.\n    match.length = match.length - 1;\n    return match;\n  } else {\n    return null;\n  }\n}\n\nmodule.exports = matchAt;"],"mappings":"AAAA,SAASA,cAAcA,CAACC,EAAE,EAAE;EAC1B;EACA,IAAI,CAACA,EAAE,CAACC,oBAAoB,EAAE;IAC5B;IACA;IACA;IACA,IAAIC,MAAM,GAAGF,EAAE,CAACE,MAAM,GAAG,KAAK;;IAE9B;IACA,IAAIC,KAAK,GAAG,GAAG,IAAIH,EAAE,CAACI,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,IAAIJ,EAAE,CAACK,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC,IAAIL,EAAE,CAACM,OAAO,GAAG,GAAG,GAAG,EAAE;IACjG;IACA;IAAA;;IAGAN,EAAE,CAACC,oBAAoB,GAAG,IAAIM,MAAM,CAACL,MAAM,EAAEC,KAAK,CAAC;EACrD;EACA,OAAOH,EAAE,CAACC,oBAAoB;AAChC;AAEA,SAASO,OAAOA,CAACR,EAAE,EAAES,GAAG,EAAEC,GAAG,EAAE;EAC7B,IAAIV,EAAE,CAACW,MAAM,IAAIX,EAAE,CAACY,MAAM,EAAE;IAC1B,MAAM,IAAIC,KAAK,CAAC,qDAAqD,CAAC;EACxE;EACA,IAAIC,KAAK,GAAGf,cAAc,CAACC,EAAE,CAAC;EAC9Bc,KAAK,CAACC,SAAS,GAAGL,GAAG;EACrB,IAAIM,KAAK,GAAGF,KAAK,CAACG,IAAI,CAACR,GAAG,CAAC;EAC3B;EACA;EACA,IAAIO,KAAK,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,EAAE;IACnC;IACAF,KAAK,CAACE,MAAM,GAAGF,KAAK,CAACE,MAAM,GAAG,CAAC;IAC/B,OAAOF,KAAK;EACd,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF;AAEAG,MAAM,CAACC,OAAO,GAAGZ,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}