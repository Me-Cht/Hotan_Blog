{"ast":null,"code":"/* Process inline math */\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar katex = require('katex');\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n  var prevChar,\n    nextChar,\n    max = state.posMax,\n    can_open = true,\n    can_close = true;\n  prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n  nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n  // Check non-whitespace conditions for opening and closing, and\n  // check that closing delimeter isn't followed by a number\n  if (prevChar === 0x20 /* \" \" */ || prevChar === 0x09 /* \\t */ || nextChar >= 0x30 /* \"0\" */ && nextChar <= 0x39 /* \"9\" */) {\n    can_close = false;\n  }\n  if (nextChar === 0x20 /* \" \" */ || nextChar === 0x09 /* \\t */) {\n    can_open = false;\n  }\n  return {\n    can_open: can_open,\n    can_close: can_close\n  };\n}\nfunction math_inline(state, silent) {\n  var start, match, token, res, pos, esc_count;\n  if (state.src[state.pos] !== \"$\") {\n    return false;\n  }\n  res = isValidDelim(state, state.pos);\n  if (!res.can_open) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n    state.pos += 1;\n    return true;\n  }\n\n  // First check for and bypass all properly escaped delimieters\n  // This loop will assume that the first leading backtick can not\n  // be the first character in state.src, which is known since\n  // we have found an opening delimieter already.\n  start = state.pos + 1;\n  match = start;\n  while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n    // Found potential $, look for escapes, pos will point to\n    // first non escape when complete\n    pos = match - 1;\n    while (state.src[pos] === \"\\\\\") {\n      pos -= 1;\n    }\n\n    // Even number of escapes, potential closing delimiter found\n    if ((match - pos) % 2 == 1) {\n      break;\n    }\n    match += 1;\n  }\n\n  // No closing delimter found.  Consume $ and continue.\n  if (match === -1) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n    state.pos = start;\n    return true;\n  }\n\n  // Check if we have empty content, ie: $$.  Do not parse.\n  if (match - start === 0) {\n    if (!silent) {\n      state.pending += \"$$\";\n    }\n    state.pos = start + 1;\n    return true;\n  }\n\n  // Check for valid closing delimiter\n  res = isValidDelim(state, match);\n  if (!res.can_close) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n    state.pos = start;\n    return true;\n  }\n  if (!silent) {\n    token = state.push('math_inline', 'math', 0);\n    token.markup = \"$\";\n    token.content = state.src.slice(start, match);\n  }\n  state.pos = match + 1;\n  return true;\n}\nfunction math_block(state, start, end, silent) {\n  var firstLine,\n    lastLine,\n    next,\n    lastPos,\n    found = false,\n    token,\n    pos = state.bMarks[start] + state.tShift[start],\n    max = state.eMarks[start];\n  if (pos + 2 > max) {\n    return false;\n  }\n  if (state.src.slice(pos, pos + 2) !== '$$') {\n    return false;\n  }\n  pos += 2;\n  firstLine = state.src.slice(pos, max);\n  if (silent) {\n    return true;\n  }\n  if (firstLine.trim().slice(-2) === '$$') {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n  for (next = start; !found;) {\n    next++;\n    if (next >= end) {\n      break;\n    }\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n    if (pos < max && state.tShift[next] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      break;\n    }\n    if (state.src.slice(pos, max).trim().slice(-2) === '$$') {\n      lastPos = state.src.slice(0, max).lastIndexOf('$$');\n      lastLine = state.src.slice(pos, lastPos);\n      found = true;\n    }\n  }\n  state.line = next + 1;\n  token = state.push('math_block', 'math', 0);\n  token.block = true;\n  token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '') + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : '');\n  token.map = [start, state.line];\n  token.markup = '$$';\n  return true;\n}\nmodule.exports = function math_plugin(md, options) {\n  // Default options\n\n  options = options || {};\n\n  // set KaTeX as the renderer for markdown-it-simplemath\n  var katexInline = function (latex) {\n    options.displayMode = false;\n    try {\n      return katex.renderToString(latex, options);\n    } catch (error) {\n      if (options.throwOnError) {\n        console.log(error);\n      }\n      return latex;\n    }\n  };\n  var inlineRenderer = function (tokens, idx) {\n    return katexInline(tokens[idx].content);\n  };\n  var katexBlock = function (latex) {\n    options.displayMode = true;\n    try {\n      return \"<p>\" + katex.renderToString(latex, options) + \"</p>\";\n    } catch (error) {\n      if (options.throwOnError) {\n        console.log(error);\n      }\n      return latex;\n    }\n  };\n  var blockRenderer = function (tokens, idx) {\n    return katexBlock(tokens[idx].content) + '\\n';\n  };\n  md.inline.ruler.after('escape', 'math_inline', math_inline);\n  md.block.ruler.after('blockquote', 'math_block', math_block, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules.math_inline = inlineRenderer;\n  md.renderer.rules.math_block = blockRenderer;\n};","map":{"version":3,"names":["require","katex","isValidDelim","state","pos","prevChar","nextChar","max","posMax","can_open","can_close","src","charCodeAt","math_inline","silent","start","match","token","res","esc_count","pending","indexOf","push","markup","content","slice","math_block","end","firstLine","lastLine","next","lastPos","found","bMarks","tShift","eMarks","trim","blkIndent","lastIndexOf","line","block","getLines","map","module","exports","math_plugin","md","options","katexInline","latex","displayMode","renderToString","error","throwOnError","console","log","inlineRenderer","tokens","idx","katexBlock","blockRenderer","inline","ruler","after","alt","renderer","rules"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/markdown-it-katex/index.js"],"sourcesContent":["/* Process inline math */\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = require('katex');\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n    var prevChar, nextChar,\n        max = state.posMax,\n        can_open = true,\n        can_close = true;\n\n    prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n    nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n    // Check non-whitespace conditions for opening and closing, and\n    // check that closing delimeter isn't followed by a number\n    if (prevChar === 0x20/* \" \" */ || prevChar === 0x09/* \\t */ ||\n            (nextChar >= 0x30/* \"0\" */ && nextChar <= 0x39/* \"9\" */)) {\n        can_close = false;\n    }\n    if (nextChar === 0x20/* \" \" */ || nextChar === 0x09/* \\t */) {\n        can_open = false;\n    }\n\n    return {\n        can_open: can_open,\n        can_close: can_close\n    };\n}\n\nfunction math_inline(state, silent) {\n    var start, match, token, res, pos, esc_count;\n\n    if (state.src[state.pos] !== \"$\") { return false; }\n\n    res = isValidDelim(state, state.pos);\n    if (!res.can_open) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos += 1;\n        return true;\n    }\n\n    // First check for and bypass all properly escaped delimieters\n    // This loop will assume that the first leading backtick can not\n    // be the first character in state.src, which is known since\n    // we have found an opening delimieter already.\n    start = state.pos + 1;\n    match = start;\n    while ( (match = state.src.indexOf(\"$\", match)) !== -1) {\n        // Found potential $, look for escapes, pos will point to\n        // first non escape when complete\n        pos = match - 1;\n        while (state.src[pos] === \"\\\\\") { pos -= 1; }\n\n        // Even number of escapes, potential closing delimiter found\n        if ( ((match - pos) % 2) == 1 ) { break; }\n        match += 1;\n    }\n\n    // No closing delimter found.  Consume $ and continue.\n    if (match === -1) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n        if (!silent) { state.pending += \"$$\"; }\n        state.pos = start + 1;\n        return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match);\n    if (!res.can_close) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    if (!silent) {\n        token         = state.push('math_inline', 'math', 0);\n        token.markup  = \"$\";\n        token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n    return true;\n}\n\nfunction math_block(state, start, end, silent){\n    var firstLine, lastLine, next, lastPos, found = false, token,\n        pos = state.bMarks[start] + state.tShift[start],\n        max = state.eMarks[start]\n\n    if(pos + 2 > max){ return false; }\n    if(state.src.slice(pos,pos+2)!=='$$'){ return false; }\n\n    pos += 2;\n    firstLine = state.src.slice(pos,max);\n\n    if(silent){ return true; }\n    if(firstLine.trim().slice(-2)==='$$'){\n        // Single line expression\n        firstLine = firstLine.trim().slice(0, -2);\n        found = true;\n    }\n\n    for(next = start; !found; ){\n\n        next++;\n\n        if(next >= end){ break; }\n\n        pos = state.bMarks[next]+state.tShift[next];\n        max = state.eMarks[next];\n\n        if(pos < max && state.tShift[next] < state.blkIndent){\n            // non-empty line with negative indent should stop the list:\n            break;\n        }\n\n        if(state.src.slice(pos,max).trim().slice(-2)==='$$'){\n            lastPos = state.src.slice(0,max).lastIndexOf('$$');\n            lastLine = state.src.slice(pos,lastPos);\n            found = true;\n        }\n\n    }\n\n    state.line = next + 1;\n\n    token = state.push('math_block', 'math', 0);\n    token.block = true;\n    token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '')\n    + state.getLines(start + 1, next, state.tShift[start], true)\n    + (lastLine && lastLine.trim() ? lastLine : '');\n    token.map = [ start, state.line ];\n    token.markup = '$$';\n    return true;\n}\n\nmodule.exports = function math_plugin(md, options) {\n    // Default options\n\n    options = options || {};\n\n    // set KaTeX as the renderer for markdown-it-simplemath\n    var katexInline = function(latex){\n        options.displayMode = false;\n        try{\n            return katex.renderToString(latex, options);\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    };\n\n    var inlineRenderer = function(tokens, idx){\n        return katexInline(tokens[idx].content);\n    };\n\n    var katexBlock = function(latex){\n        options.displayMode = true;\n        try{\n            return \"<p>\" + katex.renderToString(latex, options) + \"</p>\";\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    }\n\n    var blockRenderer = function(tokens, idx){\n        return  katexBlock(tokens[idx].content) + '\\n';\n    }\n\n    md.inline.ruler.after('escape', 'math_inline', math_inline);\n    md.block.ruler.after('blockquote', 'math_block', math_block, {\n        alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n    });\n    md.renderer.rules.math_inline = inlineRenderer;\n    md.renderer.rules.math_block = blockRenderer;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}