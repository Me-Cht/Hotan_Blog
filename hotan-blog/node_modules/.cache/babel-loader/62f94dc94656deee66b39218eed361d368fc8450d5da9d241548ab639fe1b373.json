{"ast":null,"code":"/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\nvar matchAt = require(\"match-at\");\nvar ParseError = require(\"./ParseError\");\n\n// The main lexer class\nfunction Lexer(input) {\n  this._input = input;\n}\n\n// The resulting token returned from `lex`.\nfunction Token(text, data, position) {\n  this.text = text;\n  this.data = data;\n  this.position = position;\n}\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - matches symbol combinations which result in a single output character\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more letters\n * - matches a backslash followed by any BMP character, including newline\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar tokenRegex = new RegExp(\"([ \\r\\n\\t]+)|(\" +\n// whitespace\n\"---?\" +\n// special combinations\n\"|[!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" +\n// single codepoint\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" +\n// surrogate pair\n\"|\\\\\\\\(?:[a-zA-Z]+|[^\\uD800-\\uDFFF])\" +\n// function name\n\")\");\nvar whitespaceRegex = /\\s*/;\n\n/**\n * This function lexes a single normal token. It takes a position and\n * whether it should completely ignore whitespace or not.\n */\nLexer.prototype._innerLex = function (pos, ignoreWhitespace) {\n  var input = this._input;\n  if (pos === input.length) {\n    return new Token(\"EOF\", null, pos);\n  }\n  var match = matchAt(tokenRegex, input, pos);\n  if (match === null) {\n    throw new ParseError(\"Unexpected character: '\" + input[pos] + \"'\", this, pos);\n  } else if (match[2]) {\n    // matched non-whitespace\n    return new Token(match[2], null, pos + match[2].length);\n  } else if (ignoreWhitespace) {\n    return this._innerLex(pos + match[1].length, true);\n  } else {\n    // concatenate whitespace to a single space\n    return new Token(\" \", null, pos + match[1].length);\n  }\n};\n\n// A regex to match a CSS color (like #ffffff or BlueViolet)\nvar cssColor = /#[a-z0-9]+|[a-z]+/i;\n\n/**\n * This function lexes a CSS color.\n */\nLexer.prototype._innerLexColor = function (pos) {\n  var input = this._input;\n\n  // Ignore whitespace\n  var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n  pos += whitespace.length;\n  var match;\n  if (match = matchAt(cssColor, input, pos)) {\n    // If we look like a color, return a color\n    return new Token(match[0], null, pos + match[0].length);\n  } else {\n    throw new ParseError(\"Invalid color\", this, pos);\n  }\n};\n\n// A regex to match a dimension. Dimensions look like\n// \"1.2em\" or \".4pt\" or \"1 ex\"\nvar sizeRegex = /(-?)\\s*(\\d+(?:\\.\\d*)?|\\.\\d+)\\s*([a-z]{2})/;\n\n/**\n * This function lexes a dimension.\n */\nLexer.prototype._innerLexSize = function (pos) {\n  var input = this._input;\n\n  // Ignore whitespace\n  var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n  pos += whitespace.length;\n  var match;\n  if (match = matchAt(sizeRegex, input, pos)) {\n    var unit = match[3];\n    // We only currently handle \"em\" and \"ex\" units\n    if (unit !== \"em\" && unit !== \"ex\") {\n      throw new ParseError(\"Invalid unit: '\" + unit + \"'\", this, pos);\n    }\n    return new Token(match[0], {\n      number: +(match[1] + match[2]),\n      unit: unit\n    }, pos + match[0].length);\n  }\n  throw new ParseError(\"Invalid size\", this, pos);\n};\n\n/**\n * This function lexes a string of whitespace.\n */\nLexer.prototype._innerLexWhitespace = function (pos) {\n  var input = this._input;\n  var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n  pos += whitespace.length;\n  return new Token(whitespace[0], null, pos);\n};\n\n/**\n * This function lexes a single token starting at `pos` and of the given mode.\n * Based on the mode, we defer to one of the `_innerLex` functions.\n */\nLexer.prototype.lex = function (pos, mode) {\n  if (mode === \"math\") {\n    return this._innerLex(pos, true);\n  } else if (mode === \"text\") {\n    return this._innerLex(pos, false);\n  } else if (mode === \"color\") {\n    return this._innerLexColor(pos);\n  } else if (mode === \"size\") {\n    return this._innerLexSize(pos);\n  } else if (mode === \"whitespace\") {\n    return this._innerLexWhitespace(pos);\n  }\n};\nmodule.exports = Lexer;","map":{"version":3,"names":["matchAt","require","ParseError","Lexer","input","_input","Token","text","data","position","tokenRegex","RegExp","whitespaceRegex","prototype","_innerLex","pos","ignoreWhitespace","length","match","cssColor","_innerLexColor","whitespace","sizeRegex","_innerLexSize","unit","number","_innerLexWhitespace","lex","mode","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/katex/src/Lexer.js"],"sourcesContent":["/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\nvar matchAt = require(\"match-at\");\n\nvar ParseError = require(\"./ParseError\");\n\n// The main lexer class\nfunction Lexer(input) {\n    this._input = input;\n}\n\n// The resulting token returned from `lex`.\nfunction Token(text, data, position) {\n    this.text = text;\n    this.data = data;\n    this.position = position;\n}\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - matches symbol combinations which result in a single output character\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more letters\n * - matches a backslash followed by any BMP character, including newline\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar tokenRegex = new RegExp(\n    \"([ \\r\\n\\t]+)|(\" +                                // whitespace\n    \"---?\" +                                          // special combinations\n    \"|[!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" +  // single codepoint\n    \"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" +               // surrogate pair\n    \"|\\\\\\\\(?:[a-zA-Z]+|[^\\uD800-\\uDFFF])\" +           // function name\n    \")\"\n);\n\nvar whitespaceRegex = /\\s*/;\n\n/**\n * This function lexes a single normal token. It takes a position and\n * whether it should completely ignore whitespace or not.\n */\nLexer.prototype._innerLex = function(pos, ignoreWhitespace) {\n    var input = this._input;\n    if (pos === input.length) {\n        return new Token(\"EOF\", null, pos);\n    }\n    var match = matchAt(tokenRegex, input, pos);\n    if (match === null) {\n        throw new ParseError(\n            \"Unexpected character: '\" + input[pos] + \"'\",\n            this, pos);\n    } else if (match[2]) { // matched non-whitespace\n        return new Token(match[2], null, pos + match[2].length);\n    } else if (ignoreWhitespace) {\n        return this._innerLex(pos + match[1].length, true);\n    } else { // concatenate whitespace to a single space\n        return new Token(\" \", null, pos + match[1].length);\n    }\n};\n\n// A regex to match a CSS color (like #ffffff or BlueViolet)\nvar cssColor = /#[a-z0-9]+|[a-z]+/i;\n\n/**\n * This function lexes a CSS color.\n */\nLexer.prototype._innerLexColor = function(pos) {\n    var input = this._input;\n\n    // Ignore whitespace\n    var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n    pos += whitespace.length;\n\n    var match;\n    if ((match = matchAt(cssColor, input, pos))) {\n        // If we look like a color, return a color\n        return new Token(match[0], null, pos + match[0].length);\n    } else {\n        throw new ParseError(\"Invalid color\", this, pos);\n    }\n};\n\n// A regex to match a dimension. Dimensions look like\n// \"1.2em\" or \".4pt\" or \"1 ex\"\nvar sizeRegex = /(-?)\\s*(\\d+(?:\\.\\d*)?|\\.\\d+)\\s*([a-z]{2})/;\n\n/**\n * This function lexes a dimension.\n */\nLexer.prototype._innerLexSize = function(pos) {\n    var input = this._input;\n\n    // Ignore whitespace\n    var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n    pos += whitespace.length;\n\n    var match;\n    if ((match = matchAt(sizeRegex, input, pos))) {\n        var unit = match[3];\n        // We only currently handle \"em\" and \"ex\" units\n        if (unit !== \"em\" && unit !== \"ex\") {\n            throw new ParseError(\"Invalid unit: '\" + unit + \"'\", this, pos);\n        }\n        return new Token(match[0], {\n            number: +(match[1] + match[2]),\n            unit: unit,\n        }, pos + match[0].length);\n    }\n\n    throw new ParseError(\"Invalid size\", this, pos);\n};\n\n/**\n * This function lexes a string of whitespace.\n */\nLexer.prototype._innerLexWhitespace = function(pos) {\n    var input = this._input;\n\n    var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n    pos += whitespace.length;\n\n    return new Token(whitespace[0], null, pos);\n};\n\n/**\n * This function lexes a single token starting at `pos` and of the given mode.\n * Based on the mode, we defer to one of the `_innerLex` functions.\n */\nLexer.prototype.lex = function(pos, mode) {\n    if (mode === \"math\") {\n        return this._innerLex(pos, true);\n    } else if (mode === \"text\") {\n        return this._innerLex(pos, false);\n    } else if (mode === \"color\") {\n        return this._innerLexColor(pos);\n    } else if (mode === \"size\") {\n        return this._innerLexSize(pos);\n    } else if (mode === \"whitespace\") {\n        return this._innerLexWhitespace(pos);\n    }\n};\n\nmodule.exports = Lexer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}