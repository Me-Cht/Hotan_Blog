{"ast":null,"code":"// Inline parser state\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar Token = require('../token');\nvar isWhiteSpace = require('../common/utils').isWhiteSpace;\nvar isPunctChar = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n\n  this.delimiters = []; // Emphasis-like delimiters\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n  var token = new Token(type, tag, nesting);\n  if (nesting < 0) {\n    this.level--;\n  }\n  token.level = this.level;\n  if (nesting > 0) {\n    this.level++;\n  }\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  return token;\n};\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start,\n    lastChar,\n    nextChar,\n    count,\n    can_open,\n    can_close,\n    isLastWhiteSpace,\n    isLastPunctChar,\n    isNextWhiteSpace,\n    isNextPunctChar,\n    left_flanking = true,\n    right_flanking = true,\n    max = this.posMax,\n    marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n  while (pos < max && this.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n  if (!canSplitWord) {\n    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n  } else {\n    can_open = left_flanking;\n    can_close = right_flanking;\n  }\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    length: count\n  };\n};\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\nmodule.exports = StateInline;","map":{"version":3,"names":["require","Token","isWhiteSpace","isPunctChar","isMdAsciiPunct","StateInline","src","md","env","outTokens","tokens","pos","posMax","length","level","pending","pendingLevel","cache","delimiters","prototype","pushPending","token","content","push","type","tag","nesting","scanDelims","start","canSplitWord","lastChar","nextChar","count","can_open","can_close","isLastWhiteSpace","isLastPunctChar","isNextWhiteSpace","isNextPunctChar","left_flanking","right_flanking","max","marker","charCodeAt","String","fromCharCode","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/markdown-it/lib/rules_inline/state_inline.js"],"sourcesContent":["// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  this.delimiters = [];   // Emphasis-like delimiters\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}