{"ast":null,"code":"/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar assign = require('./common/utils').assign;\nvar unescapeAll = require('./common/utils').unescapeAll;\nvar escapeHtml = require('./common/utils').escapeHtml;\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n    attrs = slf.renderAttrs(token);\n  return '<code' + (attrs ? ' ' + attrs : '') + '>' + escapeHtml(tokens[idx].content) + '</code>';\n};\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n    attrs = slf.renderAttrs(token);\n  return '<pre' + (attrs ? ' ' + attrs : '') + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n};\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n    info = token.info ? unescapeAll(token.info).trim() : '',\n    langName = '',\n    highlighted,\n    i,\n    tmpAttrs,\n    tmpToken;\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n  }\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without mudofying original token.\n  // May be, one day we will add .clone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    i = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n    if (i < 0) {\n      tmpAttrs.push(['class', options.langPrefix + langName]);\n    } else {\n      tmpAttrs[i] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\\n';\n  }\n  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\\n';\n};\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);\n  return slf.renderToken(tokens, idx, options);\n};\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independed static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n  if (!token.attrs) {\n    return '';\n  }\n  result = '';\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n  return result;\n};\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n    result = '',\n    needLf = false,\n    token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n  result += needLf ? '>\\n' : '>';\n  return result;\n};\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n    result = '',\n    rules = this.rules;\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n  return result;\n};\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n  return result;\n};\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i,\n    len,\n    type,\n    result = '',\n    rules = this.rules;\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n  return result;\n};\nmodule.exports = Renderer;","map":{"version":3,"names":["require","assign","unescapeAll","escapeHtml","default_rules","code_inline","tokens","idx","options","env","slf","token","attrs","renderAttrs","content","code_block","fence","info","trim","langName","highlighted","i","tmpAttrs","tmpToken","split","highlight","indexOf","attrIndex","slice","push","langPrefix","image","renderInlineAsText","children","renderToken","hardbreak","xhtmlOut","softbreak","breaks","text","html_block","html_inline","Renderer","rules","prototype","l","result","length","nextToken","needLf","hidden","block","nesting","tag","type","renderInline","len","render","module","exports"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/fruitshop/node_modules/markdown-it/lib/renderer.js"],"sourcesContent":["/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\n\nvar assign          = require('./common/utils').assign;\nvar unescapeAll     = require('./common/utils').unescapeAll;\nvar escapeHtml      = require('./common/utils').escapeHtml;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      attrs = slf.renderAttrs(token);\n\n  return  '<code' + (attrs ? ' ' + attrs : '') + '>' +\n          escapeHtml(tokens[idx].content) +\n          '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      attrs = slf.renderAttrs(token);\n\n  return  '<pre' + (attrs ? ' ' + attrs : '') + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      highlighted, i, tmpAttrs, tmpToken;\n\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without mudofying original token.\n  // May be, one day we will add .clone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    i        = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n    if (i < 0) {\n      tmpAttrs.push([ 'class', options.langPrefix + langName ]);\n    } else {\n      tmpAttrs[i] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n\n    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'\n          + highlighted\n          + '</code></pre>\\n';\n  }\n\n\n  return  '<pre><code' + slf.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env);\n\n  return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independed static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}