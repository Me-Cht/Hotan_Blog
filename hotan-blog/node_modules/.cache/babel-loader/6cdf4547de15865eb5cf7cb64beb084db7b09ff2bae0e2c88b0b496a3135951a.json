{"ast":null,"code":"var utils = require(\"./utils\");\nvar ParseError = require(\"./ParseError\");\n\n/* This file contains a list of functions that we parse, identified by\n * the calls to defineFunction.\n *\n * The first argument to defineFunction is a single name or a list of names.\n * All functions named in such a list will share a single implementation.\n *\n * Each declared function can have associated properties, which\n * include the following:\n *\n *  - numArgs: The number of arguments the function takes.\n *             If this is the only property, it can be passed as a number\n *             instead of an element of a properties object.\n *  - argTypes: (optional) An array corresponding to each argument of the\n *              function, giving the type of argument that should be parsed. Its\n *              length should be equal to `numArgs + numOptionalArgs`. Valid\n *              types:\n *               - \"size\": A size-like thing, such as \"1em\" or \"5ex\"\n *               - \"color\": An html color, like \"#abc\" or \"blue\"\n *               - \"original\": The same type as the environment that the\n *                             function being parsed is in (e.g. used for the\n *                             bodies of functions like \\color where the first\n *                             argument is special and the second argument is\n *                             parsed normally)\n *              Other possible types (probably shouldn't be used)\n *               - \"text\": Text-like (e.g. \\text)\n *               - \"math\": Normal math\n *              If undefined, this will be treated as an appropriate length\n *              array of \"original\" strings\n *  - greediness: (optional) The greediness of the function to use ungrouped\n *                arguments.\n *\n *                E.g. if you have an expression\n *                  \\sqrt \\frac 1 2\n *                since \\frac has greediness=2 vs \\sqrt's greediness=1, \\frac\n *                will use the two arguments '1' and '2' as its two arguments,\n *                then that whole function will be used as the argument to\n *                \\sqrt. On the other hand, the expressions\n *                  \\frac \\frac 1 2 3\n *                and\n *                  \\frac \\sqrt 1 2\n *                will fail because \\frac and \\frac have equal greediness\n *                and \\sqrt has a lower greediness than \\frac respectively. To\n *                make these parse, we would have to change them to:\n *                  \\frac {\\frac 1 2} 3\n *                and\n *                  \\frac {\\sqrt 1} 2\n *\n *                The default value is `1`\n *  - allowedInText: (optional) Whether or not the function is allowed inside\n *                   text mode (default false)\n *  - numOptionalArgs: (optional) The number of optional arguments the function\n *                     should parse. If the optional arguments aren't found,\n *                     `null` will be passed to the handler in their place.\n *                     (default 0)\n *\n * The last argument is that implementation, the handler for the function(s).\n * It is called to handle these functions and their arguments.\n * It receives two arguments:\n *  - context contains information and references provided by the parser\n *  - args is an array of arguments obtained from TeX input\n * The context contains the following properties:\n *  - funcName: the text (i.e. name) of the function, including \\\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions in the overall string of the function\n *               and the arguments.\n * The latter three should only be used to produce error messages.\n *\n * The function should return an object with the following keys:\n *  - type: The type of element that this is. This is then used in\n *          buildHTML/buildMathML to determine which function\n *          should be called to build this node into a DOM node\n * Any other data can be added to the object, which will be passed\n * in to the function in buildHTML/buildMathML as `group.value`.\n */\n\nfunction defineFunction(names, props, handler) {\n  if (typeof names === \"string\") {\n    names = [names];\n  }\n  if (typeof props === \"number\") {\n    props = {\n      numArgs: props\n    };\n  }\n  // Set default values of functions\n  var data = {\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    greediness: props.greediness === undefined ? 1 : props.greediness,\n    allowedInText: !!props.allowedInText,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    handler: handler\n  };\n  for (var i = 0; i < names.length; ++i) {\n    module.exports[names[i]] = data;\n  }\n}\n\n// A normal square root\ndefineFunction(\"\\\\sqrt\", {\n  numArgs: 1,\n  numOptionalArgs: 1\n}, function (context, args) {\n  var index = args[0];\n  var body = args[1];\n  return {\n    type: \"sqrt\",\n    body: body,\n    index: index\n  };\n});\n\n// Some non-mathy text\ndefineFunction(\"\\\\text\", {\n  numArgs: 1,\n  argTypes: [\"text\"],\n  greediness: 2\n}, function (context, args) {\n  var body = args[0];\n  // Since the corresponding buildHTML/buildMathML function expects a\n  // list of elements, we normalize for different kinds of arguments\n  // TODO(emily): maybe this should be done somewhere else\n  var inner;\n  if (body.type === \"ordgroup\") {\n    inner = body.value;\n  } else {\n    inner = [body];\n  }\n  return {\n    type: \"text\",\n    body: inner\n  };\n});\n\n// A two-argument custom color\ndefineFunction(\"\\\\color\", {\n  numArgs: 2,\n  allowedInText: true,\n  greediness: 3,\n  argTypes: [\"color\", \"original\"]\n}, function (context, args) {\n  var color = args[0];\n  var body = args[1];\n  // Normalize the different kinds of bodies (see \\text above)\n  var inner;\n  if (body.type === \"ordgroup\") {\n    inner = body.value;\n  } else {\n    inner = [body];\n  }\n  return {\n    type: \"color\",\n    color: color.value,\n    value: inner\n  };\n});\n\n// An overline\ndefineFunction(\"\\\\overline\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"overline\",\n    body: body\n  };\n});\n\n// An underline\ndefineFunction(\"\\\\underline\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"underline\",\n    body: body\n  };\n});\n\n// A box of the width and height\ndefineFunction(\"\\\\rule\", {\n  numArgs: 2,\n  numOptionalArgs: 1,\n  argTypes: [\"size\", \"size\", \"size\"]\n}, function (context, args) {\n  var shift = args[0];\n  var width = args[1];\n  var height = args[2];\n  return {\n    type: \"rule\",\n    shift: shift && shift.value,\n    width: width.value,\n    height: height.value\n  };\n});\n\n// A KaTeX logo\ndefineFunction(\"\\\\KaTeX\", {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"katex\"\n  };\n});\ndefineFunction(\"\\\\phantom\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  var inner;\n  if (body.type === \"ordgroup\") {\n    inner = body.value;\n  } else {\n    inner = [body];\n  }\n  return {\n    type: \"phantom\",\n    value: inner\n  };\n});\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n  \"\\\\bigl\": {\n    type: \"open\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    type: \"open\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    type: \"open\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    type: \"open\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    type: \"close\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    type: \"close\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    type: \"close\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    type: \"close\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    type: \"rel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    type: \"rel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    type: \"rel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    type: \"rel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    type: \"textord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    type: \"textord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    type: \"textord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    type: \"textord\",\n    size: 4\n  }\n};\nvar delimiters = [\"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\", \"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\nvar fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\"\n};\n\n// Single-argument color functions\ndefineFunction([\"\\\\blue\", \"\\\\orange\", \"\\\\pink\", \"\\\\red\", \"\\\\green\", \"\\\\gray\", \"\\\\purple\", \"\\\\blueA\", \"\\\\blueB\", \"\\\\blueC\", \"\\\\blueD\", \"\\\\blueE\", \"\\\\tealA\", \"\\\\tealB\", \"\\\\tealC\", \"\\\\tealD\", \"\\\\tealE\", \"\\\\greenA\", \"\\\\greenB\", \"\\\\greenC\", \"\\\\greenD\", \"\\\\greenE\", \"\\\\goldA\", \"\\\\goldB\", \"\\\\goldC\", \"\\\\goldD\", \"\\\\goldE\", \"\\\\redA\", \"\\\\redB\", \"\\\\redC\", \"\\\\redD\", \"\\\\redE\", \"\\\\maroonA\", \"\\\\maroonB\", \"\\\\maroonC\", \"\\\\maroonD\", \"\\\\maroonE\", \"\\\\purpleA\", \"\\\\purpleB\", \"\\\\purpleC\", \"\\\\purpleD\", \"\\\\purpleE\", \"\\\\mintA\", \"\\\\mintB\", \"\\\\mintC\", \"\\\\grayA\", \"\\\\grayB\", \"\\\\grayC\", \"\\\\grayD\", \"\\\\grayE\", \"\\\\grayF\", \"\\\\grayG\", \"\\\\grayH\", \"\\\\grayI\", \"\\\\kaBlue\", \"\\\\kaGreen\"], {\n  numArgs: 1,\n  allowedInText: true,\n  greediness: 3\n}, function (context, args) {\n  var body = args[0];\n  var atoms;\n  if (body.type === \"ordgroup\") {\n    atoms = body.value;\n  } else {\n    atoms = [body];\n  }\n  return {\n    type: \"color\",\n    color: \"katex-\" + context.funcName.slice(1),\n    value: atoms\n  };\n});\n\n// There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\n// No limits, not symbols\ndefineFunction([\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arg\", \"\\\\cos\", \"\\\\cosh\", \"\\\\cot\", \"\\\\coth\", \"\\\\csc\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\tan\", \"\\\\tanh\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: false,\n    symbol: false,\n    body: context.funcName\n  };\n});\n\n// Limits, not symbols\ndefineFunction([\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\liminf\", \"\\\\limsup\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: true,\n    symbol: false,\n    body: context.funcName\n  };\n});\n\n// No limits, symbols\ndefineFunction([\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: false,\n    symbol: true,\n    body: context.funcName\n  };\n});\n\n// Limits, symbols\ndefineFunction([\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: true,\n    symbol: true,\n    body: context.funcName\n  };\n});\n\n// Fractions\ndefineFunction([\"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\"], {\n  numArgs: 2,\n  greediness: 2\n}, function (context, args) {\n  var numer = args[0];\n  var denom = args[1];\n  var hasBarLine;\n  var leftDelim = null;\n  var rightDelim = null;\n  var size = \"auto\";\n  switch (context.funcName) {\n    case \"\\\\dfrac\":\n    case \"\\\\frac\":\n    case \"\\\\tfrac\":\n      hasBarLine = true;\n      break;\n    case \"\\\\dbinom\":\n    case \"\\\\binom\":\n    case \"\\\\tbinom\":\n      hasBarLine = false;\n      leftDelim = \"(\";\n      rightDelim = \")\";\n      break;\n    default:\n      throw new Error(\"Unrecognized genfrac command\");\n  }\n  switch (context.funcName) {\n    case \"\\\\dfrac\":\n    case \"\\\\dbinom\":\n      size = \"display\";\n      break;\n    case \"\\\\tfrac\":\n    case \"\\\\tbinom\":\n      size = \"text\";\n      break;\n  }\n  return {\n    type: \"genfrac\",\n    numer: numer,\n    denom: denom,\n    hasBarLine: hasBarLine,\n    leftDelim: leftDelim,\n    rightDelim: rightDelim,\n    size: size\n  };\n});\n\n// Left and right overlap functions\ndefineFunction([\"\\\\llap\", \"\\\\rlap\"], {\n  numArgs: 1,\n  allowedInText: true\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: context.funcName.slice(1),\n    body: body\n  };\n});\n\n// Delimiter functions\ndefineFunction([\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\", \"\\\\left\", \"\\\\right\"], {\n  numArgs: 1\n}, function (context, args) {\n  var delim = args[0];\n  if (!utils.contains(delimiters, delim.value)) {\n    throw new ParseError(\"Invalid delimiter: '\" + delim.value + \"' after '\" + context.funcName + \"'\", context.lexer, context.positions[1]);\n  }\n\n  // \\left and \\right are caught somewhere in Parser.js, which is\n  // why this data doesn't match what is in buildHTML.\n  if (context.funcName === \"\\\\left\" || context.funcName === \"\\\\right\") {\n    return {\n      type: \"leftright\",\n      value: delim.value\n    };\n  } else {\n    return {\n      type: \"delimsizing\",\n      size: delimiterSizes[context.funcName].size,\n      delimType: delimiterSizes[context.funcName].type,\n      value: delim.value\n    };\n  }\n});\n\n// Sizing functions (handled in Parser.js explicitly, hence no handler)\ndefineFunction([\"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"], 0, null);\n\n// Style changing functions (handled in Parser.js explicitly, hence no\n// handler)\ndefineFunction([\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"], 0, null);\ndefineFunction([\n// styles\n\"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\",\n// families\n\"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\",\n// aliases\n\"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"], {\n  numArgs: 1,\n  greediness: 2\n}, function (context, args) {\n  var body = args[0];\n  var func = context.funcName;\n  if (func in fontAliases) {\n    func = fontAliases[func];\n  }\n  return {\n    type: \"font\",\n    font: func.slice(1),\n    body: body\n  };\n});\n\n// Accents\ndefineFunction([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\"\n// We don't support expanding accents yet\n// \"\\\\widetilde\", \"\\\\widehat\"\n], {\n  numArgs: 1\n}, function (context, args) {\n  var base = args[0];\n  return {\n    type: \"accent\",\n    accent: context.funcName,\n    base: base\n  };\n});\n\n// Infix generalized fractions\ndefineFunction([\"\\\\over\", \"\\\\choose\"], {\n  numArgs: 0\n}, function (context) {\n  var replaceWith;\n  switch (context.funcName) {\n    case \"\\\\over\":\n      replaceWith = \"\\\\frac\";\n      break;\n    case \"\\\\choose\":\n      replaceWith = \"\\\\binom\";\n      break;\n    default:\n      throw new Error(\"Unrecognized infix genfrac command\");\n  }\n  return {\n    type: \"infix\",\n    replaceWith: replaceWith\n  };\n});\n\n// Row breaks for aligned data\ndefineFunction([\"\\\\\\\\\", \"\\\\cr\"], {\n  numArgs: 0,\n  numOptionalArgs: 1,\n  argTypes: [\"size\"]\n}, function (context, args) {\n  var size = args[0];\n  return {\n    type: \"cr\",\n    size: size\n  };\n});\n\n// Environment delimiters\ndefineFunction([\"\\\\begin\", \"\\\\end\"], {\n  numArgs: 1,\n  argTypes: [\"text\"]\n}, function (context, args) {\n  var nameGroup = args[0];\n  if (nameGroup.type !== \"ordgroup\") {\n    throw new ParseError(\"Invalid environment name\", context.lexer, context.positions[1]);\n  }\n  var name = \"\";\n  for (var i = 0; i < nameGroup.value.length; ++i) {\n    name += nameGroup.value[i].value;\n  }\n  return {\n    type: \"environment\",\n    name: name,\n    namepos: context.positions[1]\n  };\n});","map":{"version":3,"names":["utils","require","ParseError","defineFunction","names","props","handler","numArgs","data","argTypes","greediness","undefined","allowedInText","numOptionalArgs","i","length","module","exports","context","args","index","body","type","inner","value","color","shift","width","height","delimiterSizes","size","delimiters","fontAliases","atoms","funcName","slice","limits","symbol","numer","denom","hasBarLine","leftDelim","rightDelim","Error","delim","contains","lexer","positions","delimType","func","font","base","accent","replaceWith","nameGroup","name","namepos"],"sources":["/Users/chenhetian/04Front_end/FruitVue0629/hotan-blog/node_modules/katex/src/functions.js"],"sourcesContent":["var utils = require(\"./utils\");\nvar ParseError = require(\"./ParseError\");\n\n/* This file contains a list of functions that we parse, identified by\n * the calls to defineFunction.\n *\n * The first argument to defineFunction is a single name or a list of names.\n * All functions named in such a list will share a single implementation.\n *\n * Each declared function can have associated properties, which\n * include the following:\n *\n *  - numArgs: The number of arguments the function takes.\n *             If this is the only property, it can be passed as a number\n *             instead of an element of a properties object.\n *  - argTypes: (optional) An array corresponding to each argument of the\n *              function, giving the type of argument that should be parsed. Its\n *              length should be equal to `numArgs + numOptionalArgs`. Valid\n *              types:\n *               - \"size\": A size-like thing, such as \"1em\" or \"5ex\"\n *               - \"color\": An html color, like \"#abc\" or \"blue\"\n *               - \"original\": The same type as the environment that the\n *                             function being parsed is in (e.g. used for the\n *                             bodies of functions like \\color where the first\n *                             argument is special and the second argument is\n *                             parsed normally)\n *              Other possible types (probably shouldn't be used)\n *               - \"text\": Text-like (e.g. \\text)\n *               - \"math\": Normal math\n *              If undefined, this will be treated as an appropriate length\n *              array of \"original\" strings\n *  - greediness: (optional) The greediness of the function to use ungrouped\n *                arguments.\n *\n *                E.g. if you have an expression\n *                  \\sqrt \\frac 1 2\n *                since \\frac has greediness=2 vs \\sqrt's greediness=1, \\frac\n *                will use the two arguments '1' and '2' as its two arguments,\n *                then that whole function will be used as the argument to\n *                \\sqrt. On the other hand, the expressions\n *                  \\frac \\frac 1 2 3\n *                and\n *                  \\frac \\sqrt 1 2\n *                will fail because \\frac and \\frac have equal greediness\n *                and \\sqrt has a lower greediness than \\frac respectively. To\n *                make these parse, we would have to change them to:\n *                  \\frac {\\frac 1 2} 3\n *                and\n *                  \\frac {\\sqrt 1} 2\n *\n *                The default value is `1`\n *  - allowedInText: (optional) Whether or not the function is allowed inside\n *                   text mode (default false)\n *  - numOptionalArgs: (optional) The number of optional arguments the function\n *                     should parse. If the optional arguments aren't found,\n *                     `null` will be passed to the handler in their place.\n *                     (default 0)\n *\n * The last argument is that implementation, the handler for the function(s).\n * It is called to handle these functions and their arguments.\n * It receives two arguments:\n *  - context contains information and references provided by the parser\n *  - args is an array of arguments obtained from TeX input\n * The context contains the following properties:\n *  - funcName: the text (i.e. name) of the function, including \\\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions in the overall string of the function\n *               and the arguments.\n * The latter three should only be used to produce error messages.\n *\n * The function should return an object with the following keys:\n *  - type: The type of element that this is. This is then used in\n *          buildHTML/buildMathML to determine which function\n *          should be called to build this node into a DOM node\n * Any other data can be added to the object, which will be passed\n * in to the function in buildHTML/buildMathML as `group.value`.\n */\n\nfunction defineFunction(names, props, handler) {\n    if (typeof names === \"string\") {\n        names = [names];\n    }\n    if (typeof props === \"number\") {\n        props = { numArgs: props };\n    }\n    // Set default values of functions\n    var data = {\n        numArgs: props.numArgs,\n        argTypes: props.argTypes,\n        greediness: (props.greediness === undefined) ? 1 : props.greediness,\n        allowedInText: !!props.allowedInText,\n        numOptionalArgs: props.numOptionalArgs || 0,\n        handler: handler,\n    };\n    for (var i = 0; i < names.length; ++i) {\n        module.exports[names[i]] = data;\n    }\n}\n\n// A normal square root\ndefineFunction(\"\\\\sqrt\", {\n    numArgs: 1,\n    numOptionalArgs: 1,\n}, function(context, args) {\n    var index = args[0];\n    var body = args[1];\n    return {\n        type: \"sqrt\",\n        body: body,\n        index: index,\n    };\n});\n\n// Some non-mathy text\ndefineFunction(\"\\\\text\", {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    greediness: 2,\n}, function(context, args) {\n    var body = args[0];\n    // Since the corresponding buildHTML/buildMathML function expects a\n    // list of elements, we normalize for different kinds of arguments\n    // TODO(emily): maybe this should be done somewhere else\n    var inner;\n    if (body.type === \"ordgroup\") {\n        inner = body.value;\n    } else {\n        inner = [body];\n    }\n\n    return {\n        type: \"text\",\n        body: inner,\n    };\n});\n\n// A two-argument custom color\ndefineFunction(\"\\\\color\", {\n    numArgs: 2,\n    allowedInText: true,\n    greediness: 3,\n    argTypes: [\"color\", \"original\"],\n}, function(context, args) {\n    var color = args[0];\n    var body = args[1];\n    // Normalize the different kinds of bodies (see \\text above)\n    var inner;\n    if (body.type === \"ordgroup\") {\n        inner = body.value;\n    } else {\n        inner = [body];\n    }\n\n    return {\n        type: \"color\",\n        color: color.value,\n        value: inner,\n    };\n});\n\n// An overline\ndefineFunction(\"\\\\overline\", {\n    numArgs: 1,\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"overline\",\n        body: body,\n    };\n});\n\n// An underline\ndefineFunction(\"\\\\underline\", {\n    numArgs: 1,\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"underline\",\n        body: body,\n    };\n});\n\n// A box of the width and height\ndefineFunction(\"\\\\rule\", {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    argTypes: [\"size\", \"size\", \"size\"],\n}, function(context, args) {\n    var shift = args[0];\n    var width = args[1];\n    var height = args[2];\n    return {\n        type: \"rule\",\n        shift: shift && shift.value,\n        width: width.value,\n        height: height.value,\n    };\n});\n\n// A KaTeX logo\ndefineFunction(\"\\\\KaTeX\", {\n    numArgs: 0,\n}, function(context) {\n    return {\n        type: \"katex\",\n    };\n});\n\ndefineFunction(\"\\\\phantom\", {\n    numArgs: 1,\n}, function(context, args) {\n    var body = args[0];\n    var inner;\n    if (body.type === \"ordgroup\") {\n        inner = body.value;\n    } else {\n        inner = [body];\n    }\n\n    return {\n        type: \"phantom\",\n        value: inner,\n    };\n});\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n    \"\\\\bigl\" : {type: \"open\",    size: 1},\n    \"\\\\Bigl\" : {type: \"open\",    size: 2},\n    \"\\\\biggl\": {type: \"open\",    size: 3},\n    \"\\\\Biggl\": {type: \"open\",    size: 4},\n    \"\\\\bigr\" : {type: \"close\",   size: 1},\n    \"\\\\Bigr\" : {type: \"close\",   size: 2},\n    \"\\\\biggr\": {type: \"close\",   size: 3},\n    \"\\\\Biggr\": {type: \"close\",   size: 4},\n    \"\\\\bigm\" : {type: \"rel\",     size: 1},\n    \"\\\\Bigm\" : {type: \"rel\",     size: 2},\n    \"\\\\biggm\": {type: \"rel\",     size: 3},\n    \"\\\\Biggm\": {type: \"rel\",     size: 4},\n    \"\\\\big\"  : {type: \"textord\", size: 1},\n    \"\\\\Big\"  : {type: \"textord\", size: 2},\n    \"\\\\bigg\" : {type: \"textord\", size: 3},\n    \"\\\\Bigg\" : {type: \"textord\", size: 4},\n};\n\nvar delimiters = [\n    \"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\",\n    \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\",\n    \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\",\n    \"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"\\\\lt\", \"\\\\gt\",\n    \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\",\n    \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\",\n    \"/\", \"\\\\backslash\",\n    \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\",\n    \"\\\\uparrow\", \"\\\\Uparrow\",\n    \"\\\\downarrow\", \"\\\\Downarrow\",\n    \"\\\\updownarrow\", \"\\\\Updownarrow\",\n    \".\",\n];\n\nvar fontAliases = {\n    \"\\\\Bbb\": \"\\\\mathbb\",\n    \"\\\\bold\": \"\\\\mathbf\",\n    \"\\\\frak\": \"\\\\mathfrak\",\n};\n\n// Single-argument color functions\ndefineFunction([\n    \"\\\\blue\", \"\\\\orange\", \"\\\\pink\", \"\\\\red\",\n    \"\\\\green\", \"\\\\gray\", \"\\\\purple\",\n    \"\\\\blueA\", \"\\\\blueB\", \"\\\\blueC\", \"\\\\blueD\", \"\\\\blueE\",\n    \"\\\\tealA\", \"\\\\tealB\", \"\\\\tealC\", \"\\\\tealD\", \"\\\\tealE\",\n    \"\\\\greenA\", \"\\\\greenB\", \"\\\\greenC\", \"\\\\greenD\", \"\\\\greenE\",\n    \"\\\\goldA\", \"\\\\goldB\", \"\\\\goldC\", \"\\\\goldD\", \"\\\\goldE\",\n    \"\\\\redA\", \"\\\\redB\", \"\\\\redC\", \"\\\\redD\", \"\\\\redE\",\n    \"\\\\maroonA\", \"\\\\maroonB\", \"\\\\maroonC\", \"\\\\maroonD\", \"\\\\maroonE\",\n    \"\\\\purpleA\", \"\\\\purpleB\", \"\\\\purpleC\", \"\\\\purpleD\", \"\\\\purpleE\",\n    \"\\\\mintA\", \"\\\\mintB\", \"\\\\mintC\",\n    \"\\\\grayA\", \"\\\\grayB\", \"\\\\grayC\", \"\\\\grayD\", \"\\\\grayE\",\n    \"\\\\grayF\", \"\\\\grayG\", \"\\\\grayH\", \"\\\\grayI\",\n    \"\\\\kaBlue\", \"\\\\kaGreen\",\n], {\n    numArgs: 1,\n    allowedInText: true,\n    greediness: 3,\n}, function(context, args) {\n    var body = args[0];\n    var atoms;\n    if (body.type === \"ordgroup\") {\n        atoms = body.value;\n    } else {\n        atoms = [body];\n    }\n\n    return {\n        type: \"color\",\n        color: \"katex-\" + context.funcName.slice(1),\n        value: atoms,\n    };\n});\n\n// There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\n// No limits, not symbols\ndefineFunction([\n    \"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arg\", \"\\\\cos\", \"\\\\cosh\",\n    \"\\\\cot\", \"\\\\coth\", \"\\\\csc\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\",\n    \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\",\n    \"\\\\tan\", \"\\\\tanh\",\n], {\n    numArgs: 0,\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: false,\n        symbol: false,\n        body: context.funcName,\n    };\n});\n\n// Limits, not symbols\ndefineFunction([\n    \"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\liminf\", \"\\\\limsup\", \"\\\\max\",\n    \"\\\\min\", \"\\\\Pr\", \"\\\\sup\",\n], {\n    numArgs: 0,\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: true,\n        symbol: false,\n        body: context.funcName,\n    };\n});\n\n// No limits, symbols\ndefineFunction([\n    \"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\",\n], {\n    numArgs: 0,\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: false,\n        symbol: true,\n        body: context.funcName,\n    };\n});\n\n// Limits, symbols\ndefineFunction([\n    \"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\",\n    \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\",\n    \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\",\n], {\n    numArgs: 0,\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: true,\n        symbol: true,\n        body: context.funcName,\n    };\n});\n\n// Fractions\ndefineFunction([\n    \"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\",\n    \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\",\n], {\n    numArgs: 2,\n    greediness: 2,\n}, function(context, args) {\n    var numer = args[0];\n    var denom = args[1];\n    var hasBarLine;\n    var leftDelim = null;\n    var rightDelim = null;\n    var size = \"auto\";\n\n    switch (context.funcName) {\n        case \"\\\\dfrac\":\n        case \"\\\\frac\":\n        case \"\\\\tfrac\":\n            hasBarLine = true;\n            break;\n        case \"\\\\dbinom\":\n        case \"\\\\binom\":\n        case \"\\\\tbinom\":\n            hasBarLine = false;\n            leftDelim = \"(\";\n            rightDelim = \")\";\n            break;\n        default:\n            throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (context.funcName) {\n        case \"\\\\dfrac\":\n        case \"\\\\dbinom\":\n            size = \"display\";\n            break;\n        case \"\\\\tfrac\":\n        case \"\\\\tbinom\":\n            size = \"text\";\n            break;\n    }\n\n    return {\n        type: \"genfrac\",\n        numer: numer,\n        denom: denom,\n        hasBarLine: hasBarLine,\n        leftDelim: leftDelim,\n        rightDelim: rightDelim,\n        size: size,\n    };\n});\n\n// Left and right overlap functions\ndefineFunction([\"\\\\llap\", \"\\\\rlap\"], {\n    numArgs: 1,\n    allowedInText: true,\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: context.funcName.slice(1),\n        body: body,\n    };\n});\n\n// Delimiter functions\ndefineFunction([\n    \"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\",\n    \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\",\n    \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\",\n    \"\\\\big\",  \"\\\\Big\",  \"\\\\bigg\",  \"\\\\Bigg\",\n    \"\\\\left\", \"\\\\right\",\n], {\n    numArgs: 1,\n}, function(context, args) {\n    var delim = args[0];\n    if (!utils.contains(delimiters, delim.value)) {\n        throw new ParseError(\n            \"Invalid delimiter: '\" + delim.value + \"' after '\" +\n                context.funcName + \"'\",\n            context.lexer, context.positions[1]);\n    }\n\n    // \\left and \\right are caught somewhere in Parser.js, which is\n    // why this data doesn't match what is in buildHTML.\n    if (context.funcName === \"\\\\left\" || context.funcName === \"\\\\right\") {\n        return {\n            type: \"leftright\",\n            value: delim.value,\n        };\n    } else {\n        return {\n            type: \"delimsizing\",\n            size: delimiterSizes[context.funcName].size,\n            delimType: delimiterSizes[context.funcName].type,\n            value: delim.value,\n        };\n    }\n});\n\n// Sizing functions (handled in Parser.js explicitly, hence no handler)\ndefineFunction([\n    \"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\",\n    \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\",\n], 0, null);\n\n// Style changing functions (handled in Parser.js explicitly, hence no\n// handler)\ndefineFunction([\n    \"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\",\n    \"\\\\scriptscriptstyle\",\n], 0, null);\n\ndefineFunction([\n    // styles\n    \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\",\n\n    // families\n    \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\",\n    \"\\\\mathtt\",\n\n    // aliases\n    \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\",\n], {\n    numArgs: 1,\n    greediness: 2,\n}, function(context, args) {\n    var body = args[0];\n    var func = context.funcName;\n    if (func in fontAliases) {\n        func = fontAliases[func];\n    }\n    return {\n        type: \"font\",\n        font: func.slice(1),\n        body: body,\n    };\n});\n\n// Accents\ndefineFunction([\n    \"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\",\n    \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\",\n    // We don't support expanding accents yet\n    // \"\\\\widetilde\", \"\\\\widehat\"\n], {\n    numArgs: 1,\n}, function(context, args) {\n    var base = args[0];\n    return {\n        type: \"accent\",\n        accent: context.funcName,\n        base: base,\n    };\n});\n\n// Infix generalized fractions\ndefineFunction([\"\\\\over\", \"\\\\choose\"], {\n    numArgs: 0,\n}, function(context) {\n    var replaceWith;\n    switch (context.funcName) {\n        case \"\\\\over\":\n            replaceWith = \"\\\\frac\";\n            break;\n        case \"\\\\choose\":\n            replaceWith = \"\\\\binom\";\n            break;\n        default:\n            throw new Error(\"Unrecognized infix genfrac command\");\n    }\n    return {\n        type: \"infix\",\n        replaceWith: replaceWith,\n    };\n});\n\n// Row breaks for aligned data\ndefineFunction([\"\\\\\\\\\", \"\\\\cr\"], {\n    numArgs: 0,\n    numOptionalArgs: 1,\n    argTypes: [\"size\"],\n}, function(context, args) {\n    var size = args[0];\n    return {\n        type: \"cr\",\n        size: size,\n    };\n});\n\n// Environment delimiters\ndefineFunction([\"\\\\begin\", \"\\\\end\"], {\n    numArgs: 1,\n    argTypes: [\"text\"],\n}, function(context, args) {\n    var nameGroup = args[0];\n    if (nameGroup.type !== \"ordgroup\") {\n        throw new ParseError(\n            \"Invalid environment name\",\n            context.lexer, context.positions[1]);\n    }\n    var name = \"\";\n    for (var i = 0; i < nameGroup.value.length; ++i) {\n        name += nameGroup.value[i].value;\n    }\n    return {\n        type: \"environment\",\n        name: name,\n        namepos: context.positions[1],\n    };\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}